	.NLIST TTM,CND
HYP	=0			;NO HYP'S
.TITLE RUNOFF	C00-09
	.CSECT
.GLOBL RUNOFF
; THIS PROGRAM WAS TAKEN DIRECTLY FROM THE PDP-10 VERSION
; AUTHORED BY BOB CLEMENTS. BY AND LARGE, THE PDP-10 OP CODES
; WERE TRANSLATED INTO THEIR PDP-11 EQUIVALENT. THIS WILL
; MAKE IT EASY TO INCORPORATE NEW CHANGES AS THEY OCCUR.
;
; THE MAIN CHANGES WERE IN THE COMMAND STRING INTERPRETER
; PORTION AND WITH THE HANDLING OF I/O. GENERALLY, THE I/O
; SIMULATES HOW IT WORKS ON THE PDP-10.
;
;SET THE FOLLOWING SWITCH NON-ZERO TO ALLOW HYPHENATION INTERFACE
.IIF	NDF,HYP		HYP = 1
;
;SET THE FOLLOWING SWITCH NON-ZERO TO USE DOUBLE-BUFFERED OUTPUT
.IIF	NDF,DBLBUF	DBLBUF = 1

	.REPT 0

	---  CORE LAYOUT  ---
-----------
  STACK
-----------

  RUNOFF
  PROGRAM
  ITSELF
----------
  HYPHENATION
  ROUTINE

----------
  DEVICE HANDLERS
----------

  INDEX LIST
----------
  FOOTNOTES

----------

FOREGROUND, IF ANY
----------

RT-11

----------




	.ENDR

.SBTTL DEFINITIONS


	.MCALL ..V2.., .CSIGEN,.SETTOP,.CLOSE,.TTYIN,.PRINT,.TTYOUT
	.MCALL .READW, .WRITW, .WRITE, .WAIT, .QSET,.SRESET,.REGDEF
	.MCALL	.RCTRLO,.DATE
	..V2..
	.REGDEF


; SIMULATED ACCUMULATOR DEFINITIONS

F.1:	.WORD 0
B:	.WORD 0
D:	.WORD 0
X:	.WORD 0
C2:	.WORD 0
S1:	.WORD 0
S2:	.WORD 0
N1:	.WORD 0

;FLAGS IN LH OF F

JUSTF=1
PJUSTF=2
FILLF=4
FFDSW=10
FOOTFG=20		;ON IF PROCESSING FROM FOOTNOTE STRING
IDXCF=40		;USED TO KEEP CASES REMEMBERED IN INDEX
GCINF=100		;ON IF CHARS IN GCINP TO READ
PAUSF=200
TJUSTF=400
ULBSF=1000		;ON IF UNDERLINING WITH BACKSPACE (ASCII)
ULMSW=2000		;ON IF UNDERLINE SHIFT-LOCKED ON
NUMBF=4000
SIGNF=10000
ULMODE=20000
ULSUPF=40000		;ON IF USER HAS SUPPRESSED UNDERLINING DUE TO
			;SOME LOSING KIND OF PRINTER
EXSP3=100000		; * * MUST BE BIT 15
;IMPURE STORAGE

IDXRF:	.BYTE	0	;INDEXING REPEATED ITEM FLAG
FSUBPG:	.BYTE	0	;SUBPAGE MODE
ULNEXT:	.BYTE	0	;UNDERLINES ON NEXT LINE
ULCHAR:	.BYTE	0	;CHARACTER TO USE (DEFAULT C.LPUS)
	.EVEN

RMARG:	.WORD 0
PRMRG:	.WORD 0
CENTC:	.WORD 0
LMARG:	.WORD 0
CAS:	.WORD 0
PAGENO:	.WORD 0
PARIND:	.WORD 0
NSPNG:	.WORD 0
LINEC:	.WORD 0
SUBPGE:	.WORD 0

;***THE FOLLOWING ADDED 27-AUG-79, D.SHEPPERD
;CNDLVL AND CNDVAR MUST BE IN THIS ORDER
CNDLVL:	.WORD	0	;CONDITIONAL FLAG
CNDVAR:	.BLKB	26.	;A-Z VARIABLES
;***

YEAR:	.WORD	0	;YEAR - 1900.
MONPTR:	.WORD	0	;POINTER TO TABLE OF MONTH NAMES
DAY:	.WORD	0	;DAY OF MONTH


TABTL=	32.*2
TABTAB:	.WORD 0
	.BLKB	TABTL
NTABS:	.WORD 0

NLPG:	.WORD 0
PNLPG:	.WORD 0

; GLOBAL VARIABLES


FOOTBF:	.WORD 0
FOOTC:	.WORD 0
FOOTP1:	.WORD 0
FOOTP2:	.WORD 0
FOOTP3:	.WORD 0
FOOTP4:	.WORD 0

FOOTWB:	.WORD 0
	.BLKB	300.
FTBUFE:
FOOTS1:	.WORD 0
FOOTS2:	.WORD 0

ICBUF:	.WORD 0
	.BLKB	50.
ICBFE:
XFIRST:	.WORD 0
XTOP:	.WORD 0
XBOT:	.WORD 0
OIXC:	.WORD 0
OIXL:	.WORD 0

EMTBLK:	.BLKW	6		;BLOCK TO BUILD EMT CALLS IN
INDCT:	.WORD	0
IBFPTR:	.WORD	0		;INPUT BUFFER POINTER
IBFCTR:	.WORD	0		;INPUT BUFFER COUNTER
OBFPTR:	.WORD	0		;OUTPUT BUFFER POINTER
OBFCTR:	.WORD	0		;OUTPUT BUFFER COUNTER
ICHAN:	.BYTE	0		;THE INPUT CHANNEL #
OCHAN:	.BYTE	0		;THE OUTPUT CHANNEL #

	IBFSIZ=	512.		;SIZE OF INPUT BUFFER
	OBFSIZ=	512.		;SIZE OF OUTPUT BUFFER


; GENERAL


.IF	NE,DBLBUF
IOQUE:	.BLKW	7*2	;2 ELEMENTS FOR QUEUE, 7 WORDS EACH
	.ENDC

T1:	.WORD 0
T2:	.WORD 0
T5:	.WORD 0
T6:	.WORD 0

LCH:	.WORD 0
PSTRP:	.WORD 0,0
N.CNT:	.WORD 0
JOBREL:	.WORD 0		;HIGHEST FREE LOCATION
JOBFF:	.WORD 0		;LOWEST FREE LOCATION
LOWPAG:	.WORD 0			;LOWEST PAGE TO PRINT
HGHPAG:	.WORD 0			;HIGHEST PAGE TO PRINT
; THESE VALUES SET AT INITIALIZATION TIME OR WITH THE /LIMIT:LOW:HIGH
; SWITCH IN THE COMMAND

HWPLN:	.WORD	66.	;HARDWARE PAGE LENGTH
; INITIALIZED TO 66., OR SET WITH /FORM!LENGTH SWITCH

INEOFP:	.WORD EOFDAT-1

.IF	NE,HYP
	.GLOBL MQ,MUL	
;RESERVE TEMPORARY STORAGE FOR FPP MULTIPLY/DIVIDE
MQ:	.WORD 0		;SOURCE
MUL:	.WORD 0		;DESTINATION
	.ENDC

LIMIT:	.LIMIT		;ADDRESS OF LINKED PROGRAM
DEFEXT:	.RAD50 /RNO/
	.RAD50 /DOC/
	.WORD	0,0
OUTBLK:	0		;BLOCK #'S
INBLK:	0
.IIF	NE,HYP	HYPH:	0	;HYPHENATE SWITCH

IN.BUF:	.BLKB	IBFSIZ		;THE INPUT BUFFER
OU.BF1:	.BLKB	OBFSIZ		;THE FIRST OUTPUT BUFFER


.IF	NE,DBLBUF
OU.BF2:	.BLKB	OBFSIZ		;THE SECOND OUTPUT BUFFER
OB:	.WORD	OU.BF1
	.WORD	OU.BF2
OBFSWT:	.WORD	0		;THE OUTPUT BUFFER SWITCHER SWITCH
.ENDC


; LINE TEMPS
LINBK:	.WORD 0
SPCNT:	.WORD 0
LSTSP:	.WORD 0
LINNSC:	.WORD 0

LNIN1:	.WORD 0
LNIN2:	.WORD 0
LOUT1:	.WORD 0
LOUT2:	.WORD 0

LINBF:	.WORD 0
	.BLKB	132.		;*****
LINBFE:
GCINP:	.WORD 0
GCIN2:	.WORD 0
GCSCH:	.WORD 0

CMSTP:	.WORD 0
CMST2:	.WORD 0

CMBF:	.WORD 0
	.BLKB	80.		;****

TTLP1:	.WORD 0
TTLP2:	.WORD 0
TTLBUF:	.WORD 0
	.BLKB	50.		;****
TTLBFE:
STTLP1:	.WORD 0
STTLP2:	.WORD 0
STTLBF:	.WORD 0
	.BLKB	50.		;****
STLBFE:

EXSP1:	.WORD 0
EXSP2:	.WORD 0
ULMCH:	.WORD 0

NSPCH:	.WORD 0
LSTNSP:	.WORD 0
ULPOS:	.WORD 0
CPOS:	.WORD 0
ULPT1:	.WORD 0
ULPBF:	.WORD 0
	.BLKB	250.		;****
;END OF VARIABLES
;PARAMETERS

SHUP='^			;UPPER CASE INDICATOR
SHDN='\			;LOWER CASE INDICATOR
CWARN='_		;QUOTE NEXT CHARACTER
ULCHI='&		;UNDERLINE COMMAND IN INPUT DATA
ULCHS=32		;UNDERLINE CHARACTER IN INTERNAL STORAGE
			; MUST BE .LT. C.QTS
QTSP='#			;QUOTED (NONEXPANDABLE) SPACE IN INPUT FILE

IRMRG=60.		;INITIAL RIGHT MARGIN
ILMRG=0			;INITIAL LEFT MARGIN
INLPG=60.		;INITIAL LENGTH OF PAGE

;CHARACTERS FOR CREF

C.CR=15
C.LF=12
C.SPC=40
C.FF=14
C.TAB=11
C.CMA=',
C.BS=10			;BACKSPACE CHARACTER
C.NXS=177		;NON-EXPANDABLE SPACE (INTERNAL)
C.QTS=37		;QUOTED SPACE. MUST BE C.SPC-1 FOR COMPARES
C.PD='.			;PERIOD. FOR SPECIAL SPACING AFTER PERIOD
C.EOF='Z-100		;END OF FILE
C.EFNT='!		;END OF FOOTNOTE
C.LPUS=	'_		;LINE-PRINTER UNDERSCORE IN OUTPUT FILE
C.MINS=	'-		;MINUS SIGN FOR NEXT-LINE UNDERSCORE
C.SEMI=73		;SEMICOLON

.SBTTL INPUT SECTION

;INPUT LINE

LINNS:	JSR R5, WLNIN1		;WRITE CHAR IN LINE BUFFER
	MOV	R1, LCH		;STORE AS LAST CHARACTER
	INC LINNSC		;COUNT NON-SPACING CHARACTERS
LIN1:	JSR R5, GCIN		;READ CHARACTER WITH PRE-TRANSLATE
	CMP	R1, #C.TAB		;TAB?
	BNE	2$		;NOT A TAB
	JMP	LTAB		;TABS ARE TABS
2$:	CMP	R1, #C.CR		;CRR RET?
	BNE 3$
	JMP LCR			;YES. GO LOOK FOR LF
3$:	CMP	R1, #C.QTS		;SOME OTHER CONTROL CHARACTER?
	BLT LINNS		;YES. TREAT AS NON-SPACING
	CMP	R1, #C.NXS		;NON EXPANDABLE SPACE?
	BEQ 4$
	CMP	R1, #C.SPC		;OR REGULAR SPACE?
	BNE	LIN3
4$:	JMP	LSPAC		;GO HANDLE SPACING
LIN3:	JSR R5, WLNIN1		;WRITE CHAR IN INPUT BUFFER
	MOV	R1, LCH		;SAVE AS LAST CHARACTER
	DEC LINBK		;TIME TO BREAK LINE YET?
	BGE LIN1		;NO. LOOP FOR MORE
.IF	NE,HYP
	TST	HYPH		;HYPHENATE?
	BEQ	5$		;NO
	BIT	#JUSTF, F.1	;ANY JUSTIFICATION?
	BEQ	5$		;NO,  SO CAN'T HYPHENATE
	JSR	PC, FINLN	;GO FINISH HYPHENATED LINE
	.ENDC
5$:	JSR R5, OUTLJ		;YES. OUTPUT LINE, JUSTIFIED IF FLAGS
				; SAY SO,  AND SET FOR NEXT LINE
	BR	LIN1		;PROCESS NEXT LINE.
.IF	NE,HYP
;DO THE TERMINATION FOR HYPHENATING
;
FINLN:	MOV	#LNIN1, R4
	MOV	2(R4), R4
	MOV	R4, TEMP		;REMEMBER END OF LINE
FIN10:	JSR	R5, GCIN		;GET A CHARACTER
	CMP	R1, #'A		;IT MUST
	BLT	FINEX		;BE
	CMP	R1, #'Z		;ONLY
	BLE	FIN01		;ALPHABETIC
	CMP	R1, #'A+40
	BLT	FINEX
	CMP	R1, #'Z+40
	BGT	FINEX
FIN01:	JSR	R5, WLNIN1	;PUT CHARACTER IN BUFFER
	MOV	R1, LCH
	BR	FIN10
FINEX:	MOV	R0,-(SP)	;SAVE ALL USED REGISTERS
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	R3,-(SP)
	MOV	#LNIN1,R0	;STORE
	MOV	2(R0),R0	;A ZERO
	INC	R0		;TEMPORARILY AT THE
	CLRB	@R0		;END OF THE BUFFER
	MOV	LSTSP,R0	;GET ADDRESS
	CMPB	(R0)+,(R0)+	;OF LAST WORD
	.GLOBL	HYPHEN,HYPEDF
	CLR	HYPEDF
	JSR	PC,HYPHEN	;TRY TO HYPHENATE THE WORD
	MOV	LSTSP,R1	;ADDRESS OF LAST SPACE
	MOV	TEMP,R0		;ADDRESS OF REAL END OF LINE
FIN02:	TSTB	-(R0)		;IS THIS A PLACE TO INSERT A HYPHEN?
	BMI	FIN03		;YES
	CMP	R0,R1		;NO, SHOULD I LOOK FARTHER?
	BHI	FIN02		;YES
	CLR	R1		;CLEAR MASK
	BR	FIN05
FIN04A:	BISB	R1,@LSTSP	;RESET THE DESIRED ONE ONLY
FIN04:	MOV	(SP)+,R3	;NO, RESTORE AND RETURN
	MOV	(SP)+,R2
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	JSR	R5,WLNIN1	;SAVE LEFT OVER CHAR.
	RTS	PC
FIN03:	DEC	R0
	MOV	R0,LSTSP	;SET POINTER TO FAKE SPACE
	INC	SPCNT		;COUNT THE FAKE SPACE
	MOV	R1,R0		;GET START OF WORD
	MOV	#200,R1		;SET BIT MASK
FIN05:	TSTB	(R0)+
	BEQ	FIN04A
	BPL	FIN05
	BICB	#200,-1(R0)	;WIPE OUT ALL OTHER HYPHENATIONS
	BR	FIN05
TEMP:	0
	.ENDC
;SUBROUTINE TO INITIALIZE COUNTS AND POINTERS FOR A NEW LINE

LINSET:	MOV RMARG,R2		;COMPUTE REAL WIDTH OF LINE
	SUB LMARG,R2		;AS DIFFERENCE OF MARGINS
	SUB INDCT,R2		;MINUS INDENTING
	MOV R2, LINBK		;STORE IN LINE-BREAK COUNT
	MOV #-1,SPCNT		;INITIAL COUNTS OF SPACING
	CLR NSPCH		; AND NON-SPACING CHARS
	CLR CPOS		;CARRIAGE POSITION IS FAR LEFT
	CLR LINNSC		;NO NON-SPACING CHARACTERS
	MOV #ULPBF,ULPOS	;UNDERLINE POSITION BUFFER AT START
	MOV LNIN1,LNIN2		;CLEAR LINE INPUT BUFFER BY MOVING 
				; END POINTER BACK TO START
	MOV LNIN1,LSTSP		;SET LAST SPACING CHARACTER BACK HERE
	DEC LSTSP		;MINUS ONE, SO OFF START OF BUFFER
	RTS R5			;RETURN FROM LINSET

;SPECIAL CHARACTERS DURING LINE INPUT

LTAB:	MOV LNIN2,R2		;DETERMINE PRESENT POSITION
	SUB LNIN1,R2
	SUB LINNSC,R2
	ADD LMARG,R2
	ADD INDCT,R2
	JSR R5,TAB		;FIND WHERE NEXT TAB STOP IS
	CMP R2, LINBK		;WOULD THAT MANY EQUAL OR EXCEED LINE SIZE?
	BGE LSPAC		;YES. TREAT AS SPACE, NOT TAB
	MOV R2, X			;NO. NEGATE NUMBER OF SPACES
	NEG X
	ADD X,LINBK		;AND DECREMENT LINBK COUNT BY THAT AMOUNT
	MOV #C.QTS, R1		;PUT N QUOTED SPACES IN BUFFER
..008:	JSR R5,WLNIN1		; ..
	INC X			; ..
	BLT	..008
..011:	JMP	LIN1
;HERE ON SPACE IN INPUT FILE, OR ON NON-EXPANDABLE SPACE. ALSO HERE ON
;TAB WHICH COULDN'T BE SATISFIED SO IS MADE A SPACE
;NOT HERE ON QUOTED SPACES.

LSPAC:	BIT #FILLF,F.1		;FILLING INPUT BEYOND BREAKS?
	BEQ LSPC1		;NO. SIMPLER PROCESSING
	MOV LNIN2,R2		;FILTER OUT LEADING SPACES
	DEC R2			;GET START OF BUFFER MINUS ONE
	CMP R2, LSTSP		;IS THAT WHERE LAST SPACE IS?
	BLOS	..011		;YES. JUST IGNORE THIS SPACE
	MOV LCH,R1		;GET PREVIOUS CHARACTER. WHAT WAS IT?
	CMP R1, #C.SPC		;A SPACE?
	BEQ ..011
	CMP R1, #C.NXS		;OR NON-EXPANDABLE SPACE?
	BEQ	..011		;YES. FILTER MULTIPLE SPACES
	CMP R1, #C.PD		;PERIOD FOLLOWED BY SPACE?
	BNE LSPC1
	TST LINBK		;YES. ANY MORE ROOM LEFT?
	BLOS LSPC1		;NO. JUST STORE THE SPACE
	MOV LNIN2,LSTSP		;YES. FORCE DOUBLE SPACE ON OUTPUT FILE
				;SAVE POINTER AT LAST (THIS) SPACE.
	MOV LINNSC,LSTNSP	;POSITION OF LAST NON-SPACING CHARACTER
				;SAVE AS LST ...
	INC SPCNT		;COUNT SPACING CHARACTER
	MOV #C.SPC,R1		;WRITE THIS SPACE INTO BUFFER
	JSR R5,WLNIN1		; ..
	DEC LINBK		;AND COUNT FOLLOWING CHARACTER
	MOV #C.NXS,R1		;NON-EXPANDABLE SPACE
	BR	..013		; TO BUFFER. THUS 2 IF ANY AT ALL AFTER PD

LSPC1:	MOV LNIN2,LSTSP		;HERE TO STORE AND COUNT A SPACE
				;SAVE POSITION OF THIS SPACE
	MOV LINNSC,LSTNSP	;AND NON-SPACING CHAR POSN
				; ..
	INC SPCNT		;COUNT THIS SPACE
	MOV #C.SPC,R1		;SPACE CHARACTER (EXPANDABLE)
..013:	JMP LIN3		; ..
;HERE ON CARRIAGE RETURN ON INPUT FILE. ASSUMES LF FOLLOWS

ENDBCM:	JSR	R5, LINSET	;SET FOR NEW LINE (BREAK COMMAND)
LCR:	JSR R5,GCIN		;GET FILE CHARACTER
	CMPB	R1,#C.LF		;IS IT LINEFEED?
	BEQ	LGO		;YES
	CMPB	R1,#C.SEMI	;IS IT SEMICOLON?
	BNE LCR			;SHOULD HAVE BEEN. THROW THIS AWAY.

;ENTER HERE AFTER INITIALIZATION.

LGO:	JSR R5,CCIN		;READ INITIAL CHARACTER ON LINE
	CMP	R1,#C.EOF		;END OF FILE?
	BNE ..016
	JMP ENDFIL		;YES. GO WRAP UP.

..016:	CMP	R1,#C.CR		;ANOTHER BLANK LINE?
	BEQ LCR			;YES. GO DISCARD
	CMP	R1,#C.EFNT		;END OF FOOTNOTE?
	BNE ..018
	BIT	#FOOTFG, F.1	;ARE WE IN THE MIDDLE OF A FOOTNOTE?
	BEQ	COMENT		;IT'S A COMMENT
	JMP FOOTND		;YES. GO FINISH FOOTNOTE PROCESSING

..018:	CMP	R1,#C.FF	;FORMFEED ON INPUT?
	BEQ LGO			;YES. IGNORE IT.
	CMP	R1,#C.PD	;PERIOD AS FIRST CHAR?
	BEQ CMN			;YES. GO READ COMMAND LINE
	MOV	R1,GCSCH	;NONE OF ABOVE SPECIAL CASES. SAVE.


;***D.S. 27-AUG-79
	TST	CNDLVL		;IN UNSATISFIELD CONDITIONAL?
	BLT	LCR		;YES. SKIP TO NEXT LINE
;***END


	BIT #FILLF,F.1		;FILLING FROM INPUT FILE?
	BNE LSPAC		;YES. TREAT AS IF A SPACE WERE INPUT
	JSR R5,OUTLIN		;NO. OUTPUT THIS LINE
	JMP	LIN1		;AND START ANOTHER.

COMENT:	JSR	R5,CCIN		;FLUSH REST OF INPUT LINE
	CMPB	R1,#C.CR
	BNE	COMENT		; UNTIL A CR COMES ALONG
	BR	LCR
.SBTTL COMMAND SCANNER
;READ AND DISPATCH ON COMMAND
CMN:	MOV #CMBF, R4		;INITIALIZE POINTER TO HOLD USER COMMAND
	JSR R5,CSP		; ..
	MOV R2,CMSTP		; ..
	MOV R2,CMST2		; ..
	MOV	SP,PEEK.F	; FOR PEEKING
	JSR R5,CMCIN		;READ FIRST CHARACTER AFTER DOT
	CMPB R1,#C.CR		;BLANK COMMAND?
	BNE	1$		; NO


;***D.S. 27-AUG-79
2$:	TST	CNDLVL		;UNSATISIFIED IF?
	BLT	LCR		;YES
	JMP	BREAK		;SKIP IT
;***


1$:	CMPB	R1,#C.SEMI	; SEMI-COLON?
	BEQ	2$		; YES- SAME AS <CR> HERE
	MOV #<ECTAB-CMTAB>/4,N.CNT	;GET LENGTH OF COMMAND TABLE
				;ACCOUNT FOR 4 BYTES PER ENTRY
	MOV #CMSTP, R4		;STORE FIRST CHARACTER OF COMMAND
	CLR R3
	JSR R5,WCI		; ..
CM2:	MOV CMTAB+2(R3),S2		;PREPARE TO READ DEFINED COMMAND
	MOV CMSTP,R2		;PREPARE POINTER TO READ USER'S COMMAND
	MOV CMST2,B		; ..
	MOV R2,T1		; ..
	MOV B,T2		;FROM TEMPORARY POINTER
CM6:	MOVB @S2,X		;GET CHARACTER OF DEFINED COMMAND
	BEQ CM7
	INC S2
				;MATCHED TO END IF NULL
CM4:	MOV #T1, R4		;GET USER'S COMMAND CHARACTER
	JSR R5,GCI		; ..
	  BR	CM5		;NEED MORE FROM FILE
	CMPB R1,X		;MATCH?
	BEQ CM6			;YES. GO READ SOME MORE
CM8:	CMP (R3)+,(R3)+			;NO. TRY NEXT COMMAND.
	DEC N.CNT
	BGT CM2


;***D.S. 27-AUG-79
	TST	CNDLVL	
	BLT	LCR		;IGNORE ERROR
;***


	BR	ILCM1		;NO MORE TO TRY. ERROR.

CM5:	MOV	SP,(PC)+	; FLAG PEEK
PEEK.F:	.WORD	0		; NON-ZERO FOR PEEK AT CHAR
	JSR R5,CMCIN		;READ USER'S COMMAND FROM FILE
	CMPB	R1,#C.CR	;END OF LINE?
	BEQ CM8			;YES. NO SUCH COMMAND
	CMPB	R1,#C.SEMI	; OR A SEMI?
	BEQ	CM8		; YES
	MOV #CMSTP, R4		;NO. STORE CHARACTER IN BUFFER
	JSR R5,WCI		; ..
	MOV CMST2,T2		;AND UPDATE TEMPORARY POINTER
				; ..
	BR CM4			;GO CHECK NEW CHARACTER

;***D.S. 27-AUG-79

CM7:	MOV PC,R5		;MOV #CM9,R5
CM9:	MOV CMTAB(R3),-(SP)	;GET OFFSET TO COMMAND ROUTINE
	BPL 1$			;NOT CONDITIONAL
	CLR	R3		;CONDITIONAL. RESET THIS FOR SET/CLEAR ROUTINE.
	SUB (SP)+,R5		;ADDR=CM9-<CM9-ADDR>
	JMP (R5)		;GOTO CONDITIONAL (ALWAYS)
1$:	TST CNDLVL		;UNSATISFIED CONDITIONAL?
	BEQ 2$			;NO
	JMP LCR			;YES. IGNORE COMMAND.
2$:	ASR (SP)		;BIT 0 MEANS DO .BREAK FIRST.
	BCC 3$			;NO BREAK
	JSR R5,OUTNJ		;.BREAK
3$:	ADD (SP),R5		;R5=CM9+<<ADDR-CM9>/2>
	ADD (SP)+,R5		;R5=R5+<<ADDR-CM9>/2>
	JMP (R5)		;GOTO ROUTINE
;***
;SUBROUTINES FOR COMMAND SCANNER

CMCIN:	JSR R5,CCIN		;READ FROM INPUT FILE
	CMP	R1,#172		;CHECK FOR LOWER CASE LETTERS
	BGT ..025
	CMP	R1,#140
	BMI	..025		;NO. RETURN CHARACTER
	BIC #40,R1		;YES. MAKE UPPER CASE FOR COMMAND ROUTINE
..025:	RTS R5			; AND RETURN UC EQUIVALENT

;ILLEGAL COMMAND ROUTINE

ILCM2:	MOV #CMSTP,R4		;ADD BAD CHARACTER TO BUFFER
	JSR R5,WCI		; ..
ILCM1:	JSR R5,CCIN		;NOW ADD REST OF LINE
	CMP	R1,#C.CR		;END OF LINE YET?
	BNE ILCM2		;NO. LOOP.
ILCM:	.PRINT	#ILCMM		;TYPEOUT ILLEGAL COMAND MESSAGE
ILCM3:	MOV #CMSTP,R4		;READ OUT COMMAND BUFFER
	JSR R5,GCI		; TO TELETYPE
	  BR ILCM5		;END OF LINE
	MOV	R1, R0		;TYPE CHARACTER
	.TTYOUT
	BR ILCM3		;LOOP FOR WHOLE LINE

ILCM5:	JSR R5,ONPAG		;TELL HIM WHAT PAGE ITS ON
IGCMD:	JMP LCR			;GO DISCARD THE REST OF COMMAND LINE

ONPAG:	.PRINT	#ILCMM2
	MOV PAGENO, R3
	JSR R5,DECTYO		;OUTPUT PAGE NUMBER
	.PRINT	#CRLFM
	RTS R5

	.SBTTL COMMAND TABLES


;***D.S. 27-AUG-79

	.REPT 0
THE COMMAND TABLE CONSISTS OF 2 ARRAYS. THE FIRST IS A TEXT ARRAY (ARRAY OF
BYTES) THAT CONTAINS THE ASCII CHARACTERS BY WHICH TO IDENTIFY A SPECIFIC
COMMAND. THE SECOND IS AN ARRAY OF 'N' ENTRIES (N BEING THE NUMBER OF COMMANDS)
WHERE EACH ENTRY IS COMPRISED OF 2 WORDS. THE FIRST OF THESE WORDS IS AN
OFFSET IN BYTES FROM THE LABEL 'CM9' TO THE ENTRY OF THE ROUTINE WHICH WILL
HANDLE THE COMMAND. ALSO BIT 0 OF THIS OFFSET WORD (ALL OFFSETS ARE AUTO-
MATICALLY EVEN) IF '1' INDICATES THAT A .BREAK COMMAND SHOULD BE EXECUTED
BEFORE DOING THE REQUEST COMMAND. IF THE OFFSET IS NEGATIVE, THE COMMAND IS
DEFINED AS BEING ONE OF THE CONDITIONAL COMMANDS AND MUST ALWAYS BE
EXECUTED (EVEN IF THE CONDITIONAL LEVEL IS BELOW 0). THESE OPTIONS ARE
GIVEN TO THE COMMAND TABLE GENERATOR BY WAY OF THE ARGUMENTS 'BRK' AND 'CND'.
THE SECOND WORD OF THE SECOND ARRAY IS THE ADDRESS OF THE FIRST BYTE OF THE
ASCIZ STRING FOR WHICH A MATCH MUST OCCUR TO RECOGNISE A COMMAND.
	.ENDR

	.MACRO CM NAME,ADDR,BRK,CND
	.CSECT STRING
...1	=.
	.ASCIZ	/NAME/
	.CSECT
...2	=ADDR-CM9
	.IIF LT,...2,.ERROR ...2  ;OFFSET TOO BIG
	.IIF NB,CND,...2=-...2	;IF CONDITIONAL, NEGATE
	.IIF NB,BRK,...2=...2!1	;IF .BREAK REQUIRED, FORCE ODD
	.WORD ...2,...1
	.ENDM
;
;	NOTE THAT THE COMMAND SCANNER REQUIRES THAT ANY COMMAND
;	WHICH IS A SUBSTRING OF ANOTHER COMMAND MUST FOLLOW IT
;	IN THE LOOKUP TABLE.
;
CMTAB:
CM	<;>,IGCMD
CM	<X>,INDEX
CM	<EC>,ENDC,,CND		;***D.S.
CM	<SV>,SETVAR		;***D.S.
CM	<CV>,CLRVAR		;***D.S.
CM	<FG>,FIGUR
CM	<FN>,FOOTN
CM	<LC>,LWCAS
CM	<LM>,SETLM,B
CM	<ND>,NDATE
CM	<NF>,FILOF,B
CM	<NJ>,JUSOF,B
CM	<NM>,NUMON
CM	<PG>,CPAGE,B
CM	<PS>,SETPG,B
CM	<PX>,PINDX,B
CM	<RM>,SETRM,B
CM	<ST>,SETSTL,B
CM	<TP>,TSTPG,B
CM	<TS>,SETTAB
CM	<UC>,UPCAS
CM	<NNM>,NUMOF
CM	<DATE>,SDATE
CM	<D>,SDATE
CM	<FILL>,FILLN,B
CM	<PAGE>,CPAGE,B
CM	<SKIP>,SKIPL,B
CM	<BLANK>,LINSKP,B
CM	<BREAK>,BREAK
CM	<BR>,BREAK
CM	<B>,LINSKP,B
CM	<NODATE>,NDATE
CM	<INDEX>,INDEX
CM	<TITLE>,SETTL,B
CM	<ENDC>,ENDC,,CND		;***D.S.
CM	<END CONDITIONAL>,ENDC,,CND	;***D.S.
CM	<CLEAR VARIABLE>,CLRVAR		;***D.S.
CM	<SET VARIABLE>,SETVAR		;***D.S.
CM	<CENTER>,CENTER,B
CM	<C>,CENTER,B
CM	<FIGURE>,FIGUR,B
CM	<IF>,IF,,CND			;***D.S.
CM	<INDENT>,INDENT,B
CM	<I>,INDENT,B
CM	<NOFILL>,FILOF,B
CM	<NUMBER>,NUMON
CM	<JUSTIFY>,JUSTN,B
CM	<J>,JUSTN,B
CM	<SPACING>,SSP,B
CM	<SP>,SSP,B
CM	<SUBPAGE>,SPAGE
CM	<FOOTNOTE>,FOOTN
CM	<F>,FILLN,B
CM	<NONUMBER>,NUMOF
CM	<SUBTITLE>,SETSTL,B
CM	<S>,SKIPL,B
CM	<NOJUSTIFY>,JUSOF,B
CM	<PARAGRAPH>,PARAG,B
CM	<TAB STOPS>,SETTAB
CM	<TEST PAGE>,TSTPG,B
CM	<T>,SETTL,B
CM	<LOWER CASE>,LWCAS
CM	<PAPER SIZE>,SETPG,B
CM	<UPPER CASE>,UPCAS
CM	<END SUBPAGE>,CPAGE
CM	<LEFT MARGIN>,SETLM,B
CM	<PRINT INDEX>,PINDX,B
CM	<P>,PARAG,B
CM	<RIGHT MARGIN>,SETRM,B
ECTAB:

;***D.S.
;READ SIGNED DECIMAL NUMBER FOR COMMAND DECODER
;NON-SKIP RETURN IF NONE FOUND
RCNO:	CLR R3			;CLEAR ANSWER AC
RCX:	BIC #SIGNF,F.1		;AND SIGN FLAG
RCN1:	JSR R5,CCIN		;READ CHARACTER FROM COMMAND LINE
	CMP	R1,#C.CR		;LEADING CARRIAGE RETURN?
	BEQ RCN5		;YES. NON-SKIP RETURN
	CMPB	R1,#C.SEMI	; OR A SEMI?
	BEQ	RCN5		; SEMI AS GOOD AS CR HERE
1$:
	CMP	R1,#C.CMA		;COMMA SEPARATING ARGS?
	BEQ RCN1		;YES DISCARD
	CMP	R1,#C.SPC		;SPACES AND TABS?
	BEQ RCN1
	CMP	R1,#C.TAB		; ..
	BEQ RCN1			;YES.  SKIP THEM
	CMP	R1,#'-		; ..
	BNE RCN2		;NO
	BIS #SIGNF,F.1		;SET SIGN NEGATIVE
	BR	RCN1

RCN3:	JSR R5,CCIN		;READ ANOTHER CHARACTER
RCN2:	CMP	R1,#'9		;THIS CHAR A DIGIT?
	BGT RCN4
	CMP	R1,#'0		; ..
	BLT RCN4		;NO.  STOP HERE.
	BIC	#^C<17>, R1
	MOV	R3,	-(SP)
	ASL	R3		;MULTIPLY BY 10.
	ASL	R3
	ADD	(SP)+,	R3
	ASL	R3
	ADD	R1,	R3
	BR	RCN3		;AND LOOP FOR MORE.

RCN4:	BIT #SIGNF,F.1		;IF SIGN NEGATIVE?
	BEQ ..035
	NEG	R3		;NEGATE NUMBER
..035:	CMP	(R5)+, (R5)+	;NUMBER FOUND.  SKIP RETURN
RCN5:	MOV	R1,GCSCH		;STORE BREAK CHARACTER
	RTS R5			;AND RETURN FROM RCNO
.SBTTL OUTPUT SECTION
;LINE OUTPUT ROUTINE. THREE ENTRY POINTS

OUTNJ:	MOV LNIN2, R2		;HERE TO OUTPUT CURRENT LINE, NOT JUSTIFIED
	JSR R5,OUTNJ2		;CLEAR TJUSTF, CALL BODY OF ROUTINE
	BIC #EXSP3,F.1		;CLEAR LEFT/RIGHT SPACING FLAG
..041:	RTS R5			;AND RETURN.

OUTLJ:	MOV LSTSP, R2		;END OF LINE IS LAST SPACE, IF ANY
	CMP R2,LNIN1		;..
	BHI ..036
OUTLIN:	MOV LNIN2, R2		;ELSE END OF INPUT LINE
..036:	BIS #TJUSTF,F.1		;COPY JUSTF TO TJUSTF
	BIT #JUSTF,F.1
	BNE ..037
OUTNJ2:	BIC #TJUSTF,F.1		; ..
..037:	MOV R2,LOUT2		;SAVE END OF LINE TO CONSIDER
	MOV LNIN1,B		;AND BEGINNING.
	MOV B,LOUT1		; ..
	CMP R2,LOUT1		;LINE EMPTY?
	BLOS	..041		;YES. NO OUTPUT
..038:	BIT #TJUSTF,F.1		;JUSTIFYING THIS LINE?
	BNE ..039
	JMP OUTNJ1		;NO
..039:	TST SPCNT		;YES, ANY SPACES IN LINE?
	BLE JUSERR		;NO. CAN'T JUSTIFY IT THEN.
	MOV RMARG, R2		;YES. COMPUTE WHERE TO EXPAND THEM
	SUB LMARG, R2		;SIZE OF LINE
	SUB INDCT, R2		; ..
	ADD LOUT1, R2		;SUBTRACT SIZE OF DATA
	SUB LOUT2, R2		;..
	ADD LSTNSP, R2		;COMPENSATE FOR NON-SPACING CHARACTERS
.IF	NE,HYP
	TST	HYPH		;HYPHENATE?
	BEQ	..040		;NO
	BITB	#200,@LSTSP	;DO WE ACCOUNT FOR A HYPHEN?
	BEQ	..040		;NO
	DEC	R2		;YES, DECREMENT COUNT
..040:
	.ENDC
	MOV	R2,	B
	CLR	R2
10$:	SUB	SPCNT,	B
	BMI	20$
	INC	R2
	BR	10$
20$:	ADD	SPCNT,	B
	MOV R2,EXSP1		;MULTIPLIER FOR ALL SPACES
	TST	F.1		;EXTRAS TO LEFT OR RIGHT?
	BMI	OUTJC1		;LEFT. STORE NUMBER OF EXTRA SPACES
	NEG B			;RIGHT. GET SPACES BEFORE EXTRAS
	ADD SPCNT,B		;..
OUTJC1:	MOV B,EXSP2		;STORE FOR LATER
OUTNJ1:	MOV INDCT, R2		;GET INDENTING IN CASE OF PARAGRAPH
	CLR INDCT		;(ONCE ONLY)
	ADD LMARG, R2		;PLUS LEFT MARGIN
	JSR R5,NSPAC		;OUTPUT THAT MANY SPACES
OUTL1:	JSR R5,GLOUT		;READ A CHARACTER FROM OUTPUT BUFFER
	  BR	OUTLE		;END OF OUTPUT BUFFER
	CMP	R1,#C.SPC		;REAL SPACE?
	BEQ OUTSP		;YES. GO SEND N OF THEM
	CMP	R1,#C.NXS		;NON-EXPANDABLE SPACE?
	BNE ..043
	MOV #C.SPC,R1		;YES. MAKE IT ONE SPACE
..043:
.IF	NE,HYP
	TST	HYPH		;HYPHENATE?
	BEQ	..044		;NO
	MOV	R1, -(SP)
..044:
	.ENDC
	JSR R5,CCOUT		;OUTPUT THE CHARACTER
.IF	NE,HYP
	TST	HYPH		;HYPHENATE?
	BEQ	OUTL1		;NO
	MOV	(SP)+,R1
	TSTB	R1		;SHOULD A HYPHEN BE TYPED?
	BPL	OUTL1		;NO
	MOV	#'-,R1
	JSR	R5,CCOUT	;OUTPUT IT
	.ENDC
	BR OUTL1		;LOOP BACK FOR MORE.

JUSERR:				;OUTPUT ERROR MESSAGE ON TTY
	.PRINT	#JUSRM1
	MOV LOUT1, R2		;COPY POINTER TO LINE
	MOV LOUT2,B		; ..
	MOV R2,T1		; ..
	MOV B,T2		; ..
JUSER1:	MOV #T1,R4		;GET CHAR FROM LINE
	JSR R5,GCI		; ..
	  BR JUSER3		;END OF LINE
	MOV	R1,	R0
	.TTYOUT
	BR JUSER1		;LOOP FOR WHOLE LINE

JUSER3:				;TYPE OUT CR-LF
	.PRINT	#CRLFM
	JSR R5,ONPAG		;TELL HIM WHERE HE LOST
	BIC #TJUSTF,F.1		;SAY NOT JUSTIFYING
	BR	OUTNJ1		;AND OUTPUT LINE WITHOUT JUSTIFYING
	.PAGE
	.SBTTL CONDITIONALS

;***D.S.

	.ENABL LSB
IF:	TST CNDLVL		;ALREADY UNSATISIFIED?
	BLT 6$			;YES. EXIT FALSE
3$:	JSR R5,CMCIN		;GET VARIABLE UNDER TEST
	JSR R5,WCI		;PASS IT
	SUB #'A,R1		;ALPHA-BETIC?
	BHIS 1$			;SO FAR, SO GOOD
	CMP #C.SPC-'A,R1	;WAS IT A SPACE?
	BEQ 3$			;YES. SKIP IT
	BR 2$			;ERROR
1$:	CMP #'Z-'A,R1		;A-Z?
	BHIS 4$			;OK
2$:	JMP ILCM1		;ERROR RETURN
4$:	TSTB CNDVAR(R1)		;VARIABLE TRUE?
	BNE 5$			;YES. EXIT TRUE
6$:	DEC CNDLVL		;BECOME UNSATISFIED
5$:	JMP LCR			;WAIT FOR .ENDC


ENDC:	TST CNDLVL		;SATISIFIED?
	BEQ 5$			;YES. IGNORE ENDC
	INC CNDLVL		;UP 1 LEVEL
	BR 5$			;CONTINUE


SETVAR:	COM R3
CLRVAR:	MOV R3,R5
8$:	JSR R5,CMCIN		;GET VARIABLE NAME
	JSR R5,WCI
	SUB #'A,R1		;A-Z?
	BHIS 7$			;MAYBE
	CMP #C.SPC-'A,R1	;WAS IT A SPACE?
	BEQ 8$			;YES. IGNORE IT
	BR 2$			;ERROR
7$:	CMP #'Z-'A,R1		;?
	BLO 2$			;ERROR
	MOVB R5,CNDVAR(R1)	;PASS FLAG
	BR 5$			;CONTINUE
	.DSABL LSB

;***D.S.
;HERE TO OUTPUT AN EXPANDABLE SPACE.
OUTSP:	MOV #C.SPC,R1		;OUTPUT A TRUE SPACE
	JSR R5,CCOUT		; ..
	BIT #TJUSTF,F.1		;ARE WE JUSTIFYING?
	BEQ OUTL1		;NO, JUST LOOP
	MOV EXSP1,R2		;YES. HOW MANY MULTIPLE SPACES?
	BLE ..045
	JSR R5,NSPAC		;IF ANY, SEND THEM.
..045:	DEC EXSP2		;TO EXTRA BLANKS YET?
	BGE OUTS1		;NO.
	TST	F.1		;YES. SPACES LEFT OR RIGHT?
	BGE	OUTS2		;RIGHT. OUTPUT A SPACE
	BR OUTL1		;LEFT. NO MORE EXTRAS, JUST LOOP

OUTS1:	TST	F.1		;LEFT OF BREAK. WANT LEFT SPACES?
	BGE	OUTL1		;NO. HOLD FOR LATER
OUTS2:	MOV #C.SPC,R1		;YES. OUTPUT A SPACE
	JSR R5,CCOUT		; ..
	BR	OUTL1		;AND LOOP FOR REST OF LINE
;END OF LINE, AND FOOTNOTE PROCESSING

OUTLE:	ADD	#EXSP3, F.1	; * * EXSP3 MUST BE BIT 15 * *
	MOV LNIN1,R2		;CLEAR INPUT LINE BUFFER
	MOV R2, R0		;BY BACKING UP POINTER
	MOV LNIN2,R2
	MOV R0,LNIN2
	CMP R2, LOUT2		;ANY LEFT TO OUTPUT?
	BLOS OUTLE4		;NO.
	MOV R2, GCIN2		;YES. SAVE POINTER
	MOV LOUT2,GCINP		; ..
				;FOR GET-CHARACTER ROUTINE
	BIS #GCINF,F.1		;NEED TO INPUT FROM BUFFER FIRST

OUTLE4:	MOV NSPNG,R2		;OUTPUT CRLFS FOR THIS LINE
	JSR R5,SKIPN		; ..
	TST FOOTC		;ANY FOOTNOTE LINE COMMANDS DECLARED?
	BEQ OUTFT1
	BIT #FOOTFG,F.1		;YES. DOING THEM ALREADY?
	BNE	OUTFT1
				;SET UP FOR NEW LINE, RETURN FROM OUTLIN
..051:	MOV NLPG,R2		;SEE IF ROOM FOR FOOTNOTES
	SUB FOOTC,R2		; ..
	CMP R2, LINEC		; ..
	BLO OUTFT1
	MOV R2, NLPG		;REDUCE EFFECTIVE PAGE SIZE
	MOV FOOTP2,FOOTP4	;ADD LATEST FOOTNOTES TO POINTER
				; ..
	CLR FOOTC		;CLEAR COUNT OF SAVED FOOTNOTE LINES
	SUB NSPNG,R2		;MINUS NORMAL SPACING
	CMP R2, LINEC		;GREATER THAN LINE COUNT?
	BHI OUTFT1
	JSR R5,BPAGE		;YES. BREAK PAGE HERE.
OUTFT1:	JMP	LINSET		; AND RETURN
;SUBROUTINE TO SKIP N LINES ON OUTPUT FILE

SKIPN:	BIT #ULMODE,F.1		;NEED TO CONSIDER SAVED UNDERLINES?
	BEQ	CCOUT3		;YES. GO DO SO.
CCOUT5:	ADD	R2,LINEC		;COUNT LINES
	CLR NSPCH		;CLEAR PER-LINE COUNTS
	CLR CPOS		; ..
CCOUL1:	MOV #CRLFM,S1		;END-OF-LINE MESSAGE
	JSR R5,FMSG		;OUTPUT CRLF TO LINE
CCOUL2:	DEC	R2		;OUTPUT AS MANY AS REQUESTED
	BGT CCOUL1
	MOV LINEC,R2		;CHECK FOR END OF PAGE
	ADD NSPNG,R2		;POSITION OF NEXT LINE IF ALLOWED
	CMP	R2,NLPG		;UP TO A FULL PAGE?
	BLE ..055
	JSR R5,BPAGE		;YES. HANDLE HEADING
..055:	RTS R5			;RETURN FROM SKIPN

;ROUTINE TO OUTPUT N SPACES TO OUTPUT FILE, N .GE. 0, N IN A.

NSPAC:	TST	R2			;RETURN IF NONE TO OUTPUT
	BLE	2$
	ADD	R2,CPOS		;UPDATE CARRIAGE POSITION
1$:	MOV #C.SPC, R1		;GET A SPACE
	JSR R5,FOUT		;OUTPUT TO FILE
	DEC	R2		;LOOP FOR N SPACES
	BGT 1$
2$:	RTS R5			;AND RETURN.

;ROUTINES TO OUTPUT A STRING TO THE OUTPUT FILE

PSTRPA:	MOV (R4),R2		;GET POINTER FROM PA
	MOV 2(R4),B		;..
	MOV	R2,PSTRP		;STORE IN TEMP
	MOV B,PSTRP+2		;..

PSTRL:	MOV #PSTRP,R4		;GET A CHARACTER FROM THE TEMP POINTER
	JSR R5,GCI		;..
	  RTS R5		;NONE LEFT
	JSR R5,CCOUT		;OUTPUT CHAR TO FILE
	BR PSTRL		;LOOP FOR WHOLE STRING

..057:	JSR R5,CCOUT		;OUTPUT TO FILE
				;OUTPUT ASCIZ FROM S1
PSTRAZ:	MOVB @S1, R1		;GET A CHARACTER
	INC S1			;IF END, QUIT
	TST	R1
	BNE	..057
	RTS	R5
.SBTTL CHARACTER PROCESSORS
;SUBROUTINE TO OUTPUT CHARACTER TO FILE, AFTER SOME TESTS

CCOUT:	CMP	R1,#ULCHS		;UNDERLINE CHARACTER?
	BNE CCOUT1		;NO.
	BIT #ULMODE,F.1		;YES.  BY LINE?
	BEQ CCOUT2		;YES.
	MOVB ULCHAR,R1		;CONVERT TO OUTPUT UNDERLINE
	BIT #ULBSF,F.1		;NO.  BY BACKSPACING?
	BEQ CCOUT1		;NO, ASSUME NON-SPACING
	JSR R5,FOUT		;YES, SEND UNDERLINE
	MOV #C.BS,R1		;AND FOLLOW WITH BACKSPACE
CCOUT1:	CMP	R1,#C.QTS		;QUOTED SPACE?
	BNE ..061
	MOV #C.SPC,R1		;YES, MAKE REAL SPACE
..061:	JSR R5,FOUT		;SEND TO OUTPUT FILE
	INC CPOS		;COUNT POSITION OF CARRIAGE
	RTS R5			;AND RETURN.

CCOUT2:	MOV CPOS,B		;YES.  STORE POSITION IN BUFFER FOR LATER
	MOVB B,@ULPOS		;INTO UNDERLINE BUFFER
	INC ULPOS		;STEP BUFFER POINTER.  (SHOULD CHECK IT)
	RTS R5			;RETURN WITHOUT TYPING THE UNDERLINE.

;CONTINUATION OF OUTPUT N LINES

CCOUT3:	MOV #ULPBF,B		;START CONSIDERING UNDERLINE BUFFER
	CMP B,ULPOS		;ANY UNDERLINES IN THE BUFFER?
	BEQ	CCOUT5		;NO.  GO SEND LINE
	MOV	R2,-(SP)		;SAVE NUMBER OF LINES TO BE OUTPUT
	BIT #ULSUPF,F.1		;UNDERLINES SUPPRESSED?
	BNE CCOUT4		;YES.  SKIP OUTPUT SECTION
	MOV B,ULPT1		;STORE START OFF BUFER
	TSTB	ULNEXT		;UNDERLINING ON NEXT LINE?
	BEQ	1$		; NO
	MOV	#CRLFM, S1	;USE THIS IF YOU FAKE UNDERSCORE WITH A 176
	JSR	R5, FMSG
	BR	2$
1$:	MOV	#C.CR, R1
	JSR	R5,	FOUT	;USE REAL UNDERSCORE (_)
2$:	CLR CPOS		;START AT BEGINNING OF LINE
CCOUT6:	MOVB @ULPT1, R2		;GET POSITION WHERE UNDERLINE GOES
	SUB CPOS, R2		;HOW FAR TO IT?
	JSR R5,NSPAC		;SPACE TO THE UNDERLINE
	MOVB ULCHAR,R1		;GET LINE-PRINTER UNDERSCORE CHARACTER
	JSR R5,FOUT		;SEND TO FILE
	INC CPOS		;COUNT POSITION
	INC ULPT1		;COUNT UNDERLINE BUFFER POINTER
	MOV ULPT1, R2
	CMP	R2,ULPOS		;UP THRU LAST UNDERLINE?
	BNE CCOUT6		;NO.  GO OUTPUT ANOTHER ONE
	TSTB	ULNEXT
	BEQ	CCOUT4
	INC	LINEC		;WE'VE PUT OUT AN EXTRA LINE
CCOUT4:	MOV #ULPBF,ULPOS	;YES.  RESET TO START OF BUFFER
	MOV (SP)+, R2		;RESTORE NUMBER OF LINES
	JMP CCOUT5		;AND GO OUTPUT THEM
;GET INPUT CHARACTER FROM SOURCE FILE

GCIN:	BIT #GCINF,F.1		;STILL READING FROM BUFFER?
	BNE GCIN1		;YES.  GO RE-READ CHARACTER
GCIN3:	TST GCSCH		;NO.  SAVED A CHARACTER?
	BGE GCIN5		;YES.  GO GET IT.
	TST ULMCH		;SAVING CHARACTER DUE TO UNDERLINE?
	BGE	ULMC1		;YES.  GO GET IT.
GCIN5:	JSR R5,CCIN		;NO.  GET CHARACTER FROM FILE.
	TST	CNDLVL		;IN CONDITIONAL? **** D.S. 9/79
	BLT	..085		;YES. EXIT AS IS **** D.S.
	CMP	R1,#CWARN		;QUOTING A CHARACTER?
	BEQ CWR1			;YES.  GO GET REAL CHARACTER
	CMP	R1,#SHUP		;UPSHIFT CHARACTER?
	BEQ SHUP1		;YES.  SEE IF SHIFT-LOCK
	CMP	R1,#SHDN		;DOWNSHIFT CHARACTER?
	BEQ SHDN1		;YES.  SEE IF SHIFT-UNLOCK
	CMP	R1,#ULCHI		;UNDERLINE REQUEST?
	BEQ ULCH			;YES.  GO PROCESS
	CMP	R1,#QTSP		;QUOTED SPACE?
	BEQ QTSP1		;YES.
	CMP	R1,#'Z		;UPPER CASE LETTER?
	BGT ..075
	CMP	R1,#'A		;..
	BLT ..075		;NO.
	ADD CAS, R1		;YES.  ADD ON CURRENT CASE
GCINR:
..075:	BIT #ULMSW,F.1		;UNDERLINE SHIFT-LOCK ON?
	BNE ULMC2		;YES.  GO HANDLE
	RTS R5			;NO.  HAVE CHARACTER NOW.

;SPECIAL CASES OF INPUT CHARACTER

QTSP1:	MOV #C.QTS, R1		;QUOTED SPACE (NO UNDERLINING)
	RTS R5			;RETURN WITHOUT UNDERLINE

GCIN1:	JSR R5,GGCINP		;GET CHARFROM INPUT BUFFER
	  BR ..077
	RTS R5			;RETURN IT.
..077:	BIC #GCINF,F.1
	BR	GCIN3		;GO READ FROM FILE, ETC.

CWR1:	JSR R5,CCIN		;READ CHARACTER.  NO TRANSLATION
	BR GCINR		;AND RETURN IT.  MAYBE UNDERLINED
;MORE SPECIAL CASES OF GET-CHARACTER ROUTINE

SHUP1:	JSR R5,CCIN		;READ A CHARACTER
	CMP	R1,#ULCHI		;UNDERLINE?  LOCK ON UNDERLINE?
	BEQ ULMON		;YES.
	CMP	R1,#SHUP		;DOUBLE UPSHIFT?
	BNE GCINR		;NO.  GO RETURN WITH TRUE CASE.
	CLR CAS			;DOUBLE UPSHIFT.  CLEAR CASE OFFSET
	BR GCIN3		;AND GO READ ANOTHER CHARACTER.

SHDN1:	JSR R5,CCIN		;GET ANOTHER CHARACTER
	CMP	R1,#ULCHI		;UNLOCK UNDERLINE?
	BEQ ULMOF		;YES.  GO DO SO.
	CMP	R1,#SHDN		;SECOND DOWNSHIFT?
	BEQ SHDN2		;YES.
	CMP	R1,#'^		;IN RANGE FOR LOWERING?
	BGT GCINR
	CMP	R1,#'@		;..
	BLT GCINR
				;NO.
	ADD #40, R1		;YES.  MAKE IT LOWER CASE
	BR GCINR		;RETURN THIS, UNDERLINED IF NEEDED.

SHDN2:	MOV #40, R2		;SET CASE OFFSET TO LC FOR LETTERS
	MOV R2,CAS		;..
	BR	GCIN3		;AND GO READ ANOTHER CHARACTER

ULMC2:				;HERE WHEN RETURNING A CHAR, BUT UNDERLINE LOCKED ON.
	CMP	R1,#C.QTS		;QUOTED SPACE?
	BEQ ..085
	CMP	R1,#C.SPC		;PRINTING CHARACTER?
	BLE	..085		;NON-PRINTING OR QUOTED SPACE, DON'T UNDERLINE
	MOV	R1,ULMCH		;THIS MAY BE UNDERLINED.  SAVE IT FOR LATER
ULCH:	INC NSPCH		;COUNT NON-SPACING INPUT
	MOV #ULCHS, R1		;CONVERT TO STORAGE UNDERLINE
	RTS R5			;AND RETURN

ULMC1:	MOV ULMCH, R1		;RESTORE SAVED CHARACTER
	MOV #-1,ULMCH		;NEGATIVE TO INDICATE NOT THERE.
..085:	RTS R5			;RETURN WITH THIS SAVED CHARACTER

ULMON:	BIS #ULMSW,F.1		;UNDERLINE LOCKED ON
	BR	GCIN3

ULMOF:	BIC #ULMSW,F.1		;UNDERLINE LOCKED OFF
	BR	GCIN3		;GO READ ANOTHER CHARACTER
;ROUTINE TO READ INPUT FROM FILE OR FOOTNOTE AS APPROPRIATE

CCIN:	MOV GCSCH, R1		;ANY CHARACTER SAVED FROM EARLIER PASS?
	BGE GCIN4		;YES.  GO RETURN IT.
	BIT #FOOTFG,F.1		;CHARACTERS COMING FROM FOOTNOTE?
	BNE FOOTCH		;YES.  GO GET ONE
	JSR R5,FIN		;NO.  READ FROM FILE
	RTS R5			;AND RETURN THAT.

GCIN4:	MOV #-1,GCSCH		;NO MORE SAVED CHARACTERS.
	RTS R5			;RETURN LAST SAVED ONE.

FOOTCH:	MOV #FOOTP3, R4		;GET CHARACTER FROM FOOTNOTE STRING
	JSR R5,GCI		;GET THE CHARACTER
	  BR FOOTHL			;NONE THERE.  I HAVE BLOWN IT GOOD
 	RTS R5			;RETURN THE CHARACTER

FOOTHL:	.PRINT	#HALTM		;GIVE THE HALT MESSAGE
	JMP RUNOFF		;RESTART RUNOFF
.SBTTL COMMANDS

INDENT:	JSR R5,OUTNJ		;OUTPUT REST OF CURRENT LINE
	JSR R5,RCNO		;READ SIGNED DECIMAL NUMBER
PARAG1:	  MOV PARIND, R3		;NONE.  USE CURRENT VALUE
	CMP	R3,RMARG		;LEGITIMATE VALUE?
	BLE ..090
	JMP ILCM		;NO.  COMPLAIN
..090:	MOV	R3,INDCT		;YES.  STORE ARGUMENT
	BR	XEBCM		;END OF BREAK COMMAND

BREAK:	JSR R5,OUTNJ		;THE SIMPLE BREAK COMMAND.
	BR	XEBCM		;RETURN AS ALL BREAK COMMANDS DO

UPCAS:	CLR	CAS		;SET CASE OFFSET TO ZERO
	BR	..092

LWCAS:	MOV #40, CAS		;SET FOR LOWER CASE OFFSET
	BR	..092		;END OF COMMAND (NOT BREAK)

NUMON:	JSR R5,RCNO		;NUMBER PAGES.  ANY PARTICULAR NUMBER?
	  MOV PAGENO, R3		;NO.  LEAVE SAME AS BEFORE
	MOV	R3,PAGENO		;STORE PAGE NUMBER
	BIS #NUMBF,F.1		;TURN ON FLAG TO CAUSE NUMBERING
	BR ..092

NUMOF:	BIC #NUMBF,F.1		;TURN OFF NUMBERING.
..092:	JMP	LCR		;END OF NON-BREAK COMMAND

;	DATE AND NODATE COMMANDS
SDATE:	.DATE		;GET MONITOR DATE
	BEQ NDATE	; NONE EXISTS
	MOV	R0,-(SP)	;SAVE DATE WORD
	BIC 	#^C37,R0	;YEAR - 1972
	ADD	#72.,R0		;YEAR - 1900
	MOV	R0,YEAR
	MOV	@SP,R0		;GET DATE WORD AGAIN
	ASL	R0
	ASL	R0
	ASL	R0
	SWAB	R0
	BIC	#^C37,R0	;DAY OF MONTH
	MOV	R0,DAY
	MOV	(SP)+,R0	;HERE'S THAT WORD AGAIN
	SWAB	R0
	BIC	#^C74,R0	;MONTH*4
	ADD	#MONTBL-4,R0
	MOV	R0,MONPTR	;POINT TO NAME OF MONTH
	BR	..092
NDATE:	CLR	YEAR		;0 YEAR MEANS DON'T PRINT DATE
	BR	..092
;PAGE COMMAND

CPAGE:	JSR R5,OUTNJ		;OUTPUT CURRENT LINE
	CLRB	FSUBPG		;ZERO SUBPAGE FLAG
	MOV #C.SPC,SUBPGE	;CONVERTS TO ASCII 'A-1
				;SAVE HERE FOR LATER USE
DPAGE:	JSR R5,BPAGE		;BREAK PAGE, HEADING
	BR	XEBCM		;END OF BREAK-CLASS COMMAND
SPAGE:	JSR R5,OUTNJ		;OUTPUT CURRENT LINE
	JSR R5,TPAGE		;BREAK PAGE, HEADING, ETC.
XEBCM:	JMP ENDBCM		;END OF BREAK CLASS MESSAGE

;TITLE COMMAND

SETTL:	MOV #TTLBUF, R4		;COMPUTE POINTER TO TITLE BUFFER
	JSR R5,CSP		; ..
	MOV R2,TTLP1		;STORE.
	MOV B,TTLP2		;..
	JSR R5,GCIN		;READ CHARACTER AFTER COMMAND
	CMP	R1,#C.SPC		;SPACE?  SKIP JUST ONE.
	BNE ..093
SETTL1:	JSR R5,GCIN		;READ A CHARACTER
..093:	CMP	R1,#C.CR		;END OF COMMAND LINE?
	BEQ	..092		;YES.  QUIT
	MOV #TTLP1, R4		;NO.  PUT CHAR IN STRING BUFFER
	JSR R5,WCI		;..
	CMP	TTLP2,#TTLBFE	;AT END OF BUFFER?
	BLO	SETTL1		; NOT YET
	.PRINT	#TTL		;TITLE
	.PRINT	#TOOBIG		;TOO LONG
	JMP	ILCM5		;ILLEGAL COMMAND
;SET RIGHT MARGIN COMMAND

SETRM:	JSR R5,OUTNJ		;BREAK-CLASS COMMAND
	JSR R5,RCNO		;GET ARGUMENT
	  MOV PRMRG, R3		;IF NONE, INITIALIZE
	CMP	R3,LMARG		;MUST ALSO BE RIGHT OF LEFT MARGIN
	BLE	..094
	MOV	R3,RMARG		;STORE RIGHT MARGIN
	BR	XEBCM		;END OF COMMAND

;SET LEFT MARGIN COMMAND

SETLM:	JSR R5,OUTNJ		;BREAK COMMAND
	JSR R5,RCNO		;GET ARGUMENT
	  MOV #ILMRG, R3		;IF NONE, INITIALIZE
	CMP	R3,RMARG		;AND LESS THAN RIGHT MARGIN?
	BGE	..094
	MOV	R3,LMARG		;OK SAVE AS LEFT MARGIN
	BR	XEBCM		;AND END BREAK-CLASS COMMAND

;PAGE SIZE COMMAND

SETPG:	JSR R5,RCNO		;GET ARGUMENT
..094:	  JMP	ILCM		;MUST BE ONE
	CMP	R3,#12		;LONG ENOUGH TO BE REASONABLE FOR HEADING
	BLE	..094
	MOV	R3, NLPG		;SAVE AS LENGTH OF THIS PAGE
	MOV	R3,PNLPG		;AND PERMANENT PAGE LENGTH
	JSR R5,RCNO		;SEE IF SECOND ARGUMENT
	  MOV PRMRG, R3		;NO
	CMP	R3,LMARG
	BLE	..094
	MOV	R3,PRMRG		;STORE PAGE WIDTH
	MOV	R3,RMARG
	JMP	LCR		;END OF COMMAND
;PARAGRAPH COMMAND

PARAG:	JSR R5,OUTNJ		;FINISH CURRENT LINE
	JSR R5,RCNO		;OPTIONAL IDENTING ARGUMENT
	  MOV PARIND, R3		;NO.  USE OLD VALUE
	MOV	R3,PARIND		;STORE PARA INDENT VALUE
	MOV LINEC, R2		;GET LINE COUNT USED ON THIS PAGE
	CMP	R2,#5		;BEYOND HEADING YET?
	BLE	..097
	MOV NSPNG, R2		;GET NORMAL LINE-SPACING
	INC R2			;COMPUTE SIZE OF PARAGRAPH BREAK
	ASR R2			;..
	MOV LINEC, R3
	ADD	R2, R3			;CHECK FOR END OF PAGE
	ADD NSPNG, R3		;HERE + PARAG. BREAK + 1 MORE
	CMP	R3, NLPG		;PAGE TOO FULL FOR THE BREAK NEEDED?
	BGE	PARAG2
	JSR R5,SKIPN		;NO.  GO SKIP N LINES (N IN A)
..097:	JMP PARAG1		;CHECK ARGUMENT AND RETURN

PARAG2:	JSR R5,BPAGE		;BREAK PAGE.  ADD HEADING
	BR	..097		;AND RETURN
;TEST PAGE COMMAND

TSTPG:	JSR R5,OUTNJ		;BREAK LINE FIRST
	JSR R5,RCNO		;GET ARGUMENT OF TEST
	  JMP ILCM		;MUST BE ONE
	ADD LINEC, R3		;ADD ON CURRENT LINE POSITION
	CMP	R3,NLPG		;COMPARE TO LENGTH W/O FOOTNOTES
	BLE ..101
	JSR R5,BPAGE		;TEST SHOWS NEAR END. BREAK PAGE.
..101:	JMP ENDBCM		;RETURN FROM TSTPG

;SPACING COMMAND

SSP:	JSR R5,OUTNJ		;BREAK LINE FIRST
	JSR R5,RCNO		;GET ARGUMENT OF SPACING COMMAND
	  JMP ILCM		;MUST BE ONE
	CMP	R3,#5		;MUST BE IN RANGE 1 TO 5
	BGT ..094
	TST	R3			;..
	BLE	..094
	MOV	R3,NSPNG		;OK.  STORE AS NORMAL SPACING
	BR	..101		;END OF SPACING COMMAND

;SUBTITLE COMMAND

SETSTL:	MOV #STTLBF, R4		;COMPUTE POINTER TO
	JSR R5,CSP		;SUBTITLE BUFFER
	MOV	R2,STTLP1		;STORE EMPTY POINTER
	MOV B,STTLP2		;..
	JSR R5,GCIN		;GET CHARACTER FROM INPUT LINE
	CMP	R1,#C.SPC		;SKIP ONE LEADING SPACE
	BNE ..104
SETST1:	JSR R5,GCIN		;GET CHARACTER FROM INPUT LINE
..104:	CMP	R1,#C.CR		;END OF LINE ON INPUT?
	BEQ	..101		;YES.  END OF SUBTITLE COMMAND
	MOV #STTLP1, R4		;NO.  WRITE INTO BUFFER
	JSR R5,WCI		;..
	CMP	STTLP2,#STLBFE	;END OF BUFFER?
	BLO	SETST1
	.PRINT	#STTL
	.PRINT	#TOOBIG
	JMP	ILCM5		;ERROR EXIT
;LINE SKIPPING COMMANDS

SKIPL:	MOV NSPNG,S2		;SKIP COMMAND.  N CURRENT LINES
	BR ..106
LINSKP:	MOV #1,S2		;BLANK COMMAND.  N REAL LINES
..106:	MOV S2,-(SP)		;SAVE S2 FOR SAFETY
	JSR R5,OUTNJ		;OUTPUT CURRENT LINE
	MOV (SP)+,S2		;RESTORE S2
	MOV LINEC, R2		;CHECK CURRENT POSITION
	CMP	R2,#5		;AT TOP OF PAGE?
	BLE	..101		;YES.  IGNORE BLANK COMMAND.
	JSR R5,RCNO		;GET OPTIONAL ARGUMENT
	  MOV #1, R3		;IF NONE, ASSUME 1
	CLR	R2
10$:	ADD	S2,	R2
	DEC	R3
	BNE	10$
	MOV	R2,	R3
	ADD LINEC, R3		;ADD CURRENT LINE
	ADD NSPNG, R3		;PLUS SPACING TO NEXT LINE
	CMP	R3,NLPG		;ROOM FOR ANOTHER?
	BLT ..108
	JMP DPAGE		;NO. MAKE A NEW PAGE
..108:	JSR R5,SKIPN		;YES.  SPACE OUT C(A) LINES
	BR	..101		;END OF COMMAND


FIGUR:	JSR R5,OUTNJ		;BREAK COMMAND
	JSR R5,RCNO		;GET ARGUMENT
	  MOV #1, R3		;IF NONE, ASSUME ONE LINE
	CMP	R3,NLPG		;CHECK FOR RATIONAL ARGUMENT
	BGT ..109
	TST	R3			;..
	BLE	..109		;BAD.  ERROR.
	MOV	R3,-(SP)		;SAVE DESIRED SPACE
	ADD LINEC, R3		;SEE IF NEED NEW PAGE FOR FIGURE
	CMP	R3,NLPG		;WOULD THIS OVERFLOW PAGE
	BLT ..111
	JSR R5,BPAGE		;YES.  BREAK PAGE
..111:	MOV (SP)+, R2		;GET BACK DESIRED SIZE
	JSR R5,SKIPN		;SPACE THAT OUT
	BR	..101		;END OF BREAK COMMAND

..109:	JMP	ILCM
JUSTN:	JSR R5,OUTNJ		;BREAK COMMAND
	BIS #JUSTF+PJUSTF,F.1	;TURN ON JUSTIFYING
	BR	..112		;AND RETURN FROM COMMAND

JUSOF:	JSR R5,OUTNJ		;BREAK CURRENT LINE
	BIC #PJUSTF+JUSTF,F.1	;TURN OFF JUSTIFY BITS
	BR	..112		;AND FINISH COMMAND

FILLN:	JSR R5,OUTNJ		;BREAK COMMAND
	BIS #FILLF+JUSTF,F.1	;TURN ON FILLING, COPY PJUSTF TO JUSTF
	BIT #PJUSTF,F.1		;COPY PERMANENT FLAG
	BNE ..112
	BIC #JUSTF,F.1		;TO CURRENT ONE.
..112:	JMP ENDBCM		;AND OF COMMAND

FILOF:	JSR R5,OUTNJ		;BREAK CURRENT LINE
	BIC #FILLF+JUSTF,F.1	;TURN OFF FILLING AND JUSTIFYING
	BR	..112		;END OF COMMAND

SETTAB:	CLR NTABS		;CLEAR NUMBER OF TABS
SETT1:	JSR R5,RCNO		;GET ANOTHER STOP IF ANY
	  JMP	LCR		;NO, RETURN
	ADD #2,NTABS		;GET POINTER
	MOV NTABS,X
	MOV X,R0
	MOV	R3, TABTAB-2(R0)	;STORE THIS TABSTOP
	CMP R0, #TABTL		;CHECK TABLE SIZE
	BLO SETT1		;OK.
	BR	..109		;TOO MANY TABS

;ROUTINE TO FIND NEXT TABSTOP FOR OUTLIN ROUTINE.  CALL
;WITH CURRENT POSITION IN A.

TAB:	CLR X			;START AT FIRST TABSTOP
	BR TAB1			;PRE-ENDCHECK, IN CASE NONE.

TAB2:	MOV X,R0
	MOV TABTAB-2(R0), R4	;GET CURRENT TAB STOP
	CMP	R2, R4			;THIS STOP BEYOND CURRENT POS?
	BLO TAB3		;YES.  GET DIFFERENCE
TAB1:	CMP X,NTABS		;LOOKED AT ALL TAB STOPS?
	BHIS ..115
	ADD #2,X			;NO.  LOOK AT ANOTHER
	BR TAB2

..115:	MOV RMARG, R4		;YES.  ASSUME A TABSTOP AT RIGHT END
TAB3:	SUB	R2, R4			;GET DISTANCE TO TABSTOP
	MOV	R4, R2			;ANSWER IN A
	RTS R5			;RETURN
;ROUTINE TO SPACE TO TOP OF FORM

FORM:	MOV LINEC, R3		;GET CURRENT LINE POSITION
	BLE	..119		;ALREADY AT TOP.  RETURN.
	BIT	#PAUSF, F.1	;SHOULD WE PAUSE?
	BEQ	10$		;NOPE
	CMP	PAGENO,LOWPAG	;PRINTING THIS PAGE?
	BLO	10$		; NO, PRESS ON REGARDLESS
	BIS	#10000, @#44	;SET SPECIAL MODE
	JSR	R5,	OUTPUT	;DUMP PARTIAL BUFFER
	.WAIT	OCHAN
	.TTYIN			;WAIT FOR ANY CHAR BEFORE PROCEDING
	CMPB	R0,#15		;DID HE HIT <CR>
	BNE	1$		; NOPE
	.TTYIN			;FLUSH THE <LF> WHICH RT-11 SENDS US
1$:	BIC	#10000, @#44	;UN-SET SPECIAL MODE
	BR	BPG3		;ASSUME GUY HAS POSITIONED PAPER PROPERLY

10$:	BIT #FFDSW,F.1		;SPACING WITH FF OR LFS
	BEQ BPG2		;LINEFEEDS
	MOV #C.FF,R1		;OUTPUT FORMFEED TO FILE
	JSR R5,FOUT		;..
	BR BPG3			;ADJUST COUNTS
BPG2:	MOV	R3,	N1
	CLR	R3
10$:	SUB	HWPLN, N1	;COMPARE WITH HARDWARE PAGE LENGTH
	BMI	1$
	INC	R3
	BR	10$
1$:	MOV	#CRLFM,S1	;PUT OUT CRLF'S
	JSR	R5,FMSG		; TO FILE
	INC N1			;..
	BLT 1$
BPG3:	CLR LINEC		;CURRENT LINE NOW ZERO
	TSTB	FSUBPG		;DON'T INCREMENT PAGE, IF SUBPAGE
	BNE	..119
	INC PAGENO		;COUNT PAGE NUMBER
..119:	RTS R5			;RETURN FROM FORM ROUTINE
;ROUTINE TO BREAK PAGE AND OUTPUT HEADING


TPAGE:	INCB	FSUBPG		;SET SUBPAGE FLAG
	INC SUBPGE		;INCREMENT SUBPAGE
BPAGE:	MOV LINEC, R2		;CURRENT LINE POSITION
	CMP	R2,#5		;IN HEADING AREA?
	BLE	..119		;YES - DON'T DO IT AGAIN
	MOV FOOTP3, R2		;SEE IF ANY DATA IN FOOTNOTE BUFFER
	CMP	R2,FOOTP4		;..
	BEQ ..121
	JMP FOOTGO		;YES.  GO PROCESS THAT FIRST
..121:
FOOTX:	JSR R5,FORM		;OUTPUT FORMFEED OF LINEFEEDS
	MOV #1, R2		;SKIP A LINE
	JSR R5,SKIPN		;..
	MOV #TTLP1, R4		;OUTPUT TITLE TO FILE
	JSR R5,PSTRPA		;PRINT STRING FROM PA
	BIT #NUMBF,F.1		;WANT PAGE NUMBER?
	BEQ BPGN		;NO.
	MOV RMARG, R2		;FIND POSITION WHERE THIS LEFT US
	ADD ULPOS, R2		;..
	SUB #ULPBF, R2		;ADD IN ANY UNDERLINES
	SUB TTLP2, R2		;AND TITLE CHARACTERS
	ADD TTLP1, R2		;..
	TSTB	FSUBPG		;SUBPAGE?
	BEQ 10$
	DEC	R2			;MAKE ROOM FOR LETTER
10$:	SUB #10, R2		;MINUS 8 FOR "PAGE NNN"
	BMI	BPGN		;NO ROOM FOR PAGE NUMBER
	JSR R5,NSPAC		;SPACE OVER TO THERE
	MOV #PGTXT, S1		;PAGE MESSAGE
	JSR R5,FMSG		;OUTPUT TO FILE
	MOV PAGENO, R3		;OUTPUT PAGE NUMBER
	JSR R5,PPGNO		;3 DIGIT DECIMAL PRINT
	TSTB	FSUBPG		;IS THIS A SUBPAGE?
	BEQ BPGN
	MOV SUBPGE,R1		;RETRIEVE THE LETTER
	ADD #' ,R1		;MAKE AN ASCII LETTER
	JSR R5,FOUT		;GET IT INTO OUTPUT BUFFER
BPGN:	MOV #1, R2		;OUTPUT THE LINE WITH TITLE
	JSR R5,SKIPN		;..
	MOV #STTLP1, R4		;OUTPUT THE SUBTITLE, IF ANY
	JSR R5,PSTRPA		;..
	TST	YEAR		; ANY DATE TO PUT OUT?
	BEQ	1$		;  NO
	BIT	#NUMBF,F.1	;ARE WE NUMBERING PAGES?
	BEQ	1$		; NO, DON'T PRINT DATE
	MOV	RMARG,R2	;OK, HOW FAR TO RIGHT MARGIN?
	ADD	ULPOS,R2
	SUB	#ULPBF,R2	;SUBTRACT UNDERLINES
	ADD	STTLP1,R2
	SUB	STTLP2,R2	;SUBTRACT SUBTITLE CHAR'S
	SUB	#10.,R2		;MAKE ROOM FOR #DD#MMM#YY
	BMI	1$		; NO ROOM!
	JSR	R5,NSPAC	; GO THERE
	MOV	DAY,R3
	JSR	R5,PPGNO	;#DD OR ##D
	MOV	#1,R2
	JSR	R5,NSPAC	;ONE MORE #
	MOV	MONPTR,S1
	JSR	R5,FMSG		;MONTH NAME GOES TO FILE
	MOV	YEAR,R3
	JSR	R5,PPGNO	;#YY UNTIL 1999
1$:	MOV #3, R2		;AND OUTPUT THIS LINE.
	JMP SKIPN		;INCLUDING SUBTITLE, AND RETURN FROM BPAGE
;SUBROUTINE FOR PAGE NUMBER OUTPUT

PPGNO:	MOV #C.SPC,R1		;LEADING SPACES IF NEEDED
	CMP	R3,#99.		;3 DIGITS?
	BGT ..124
	JSR R5,FOUT		;NO.  SPACE.
..124:	CMP	R3,#9.		;2 DIGITS?
	BGT ..125
	JSR R5,FOUT		;NO.  SPACE AGAIN.
..125:
DECPRT:	MOV	R3,	-(SP)
	CLR	R3
1$:	INC	R3
	SUB	#10.,	(SP)
	BGE	1$
	ADD	#60+10., (SP)
	DEC	R3
	BEQ	2$
	JSR	R5,	DECPRT
2$:	MOV	(SP)+,	R1
	JMP	FOUT
;CENTER COMMAND

CENTER:	JSR R5,RCNO		;SEE IF ANY ARGUMENT
	  MOV PRMRG, R3		;NO.  DEFAULT IS RIGHT SIDE OF PAPER
	MOV	R3,CENTC		;STORE
	JSR R5,OUTNJ		;OUTPUT CURRENT LINE
..127:	JSR R5,GCIN		;DISCARD REST OF THIS COMMAND
	CMPB	R1,#C.LF		; ..
	BEQ	1$		; YES
	CMPB	R1,#C.SEMI	; OR A SEMICOLON?
	BNE ..127		; ..
1$:	MOV LNIN1, R2		;CLEAR INPUT BUFFER
	MOV	R2,LNIN2		; ..
CENT1:	JSR R5,GCIN		;READ LINE TO BE CENTERED
	CMP	R1,#C.CR		;THROUGH CR
	BEQ CENT2		; CR. DONE.
	JSR R5,WLNIN1		;PUT IN LINE INPUT BUFFER
	BR CENT1		;LOOP FOR MORE

CENT2:	MOV CENTC, R2		;COMPUTE SPACING BEFORE LINE
	ADD LNIN1, R2		;AS HALF RIGHT MARGIN
	SUB LNIN2, R2		;MINUS HALF OF LINE SIZE
	ADD NSPCH, R2		; INCLUDING UNDERLINES, ETC.
	ASR	R2		;TAKE HALF
	JSR R5,NSPAC		;OUTPUT SPACES
	MOV #LNIN1, R4		;THEN OUTPUT LINE BUFFER TO FILE
	JSR R5,PSTRPA		; ..
	MOV NSPNG, R2		;THEN SPACE TO NEXT LINE
	JSR R5,SKIPN		; ..
	JMP ENDBCM		;AND RETURN AFTER COMMAND
.SBTTL INDEX OPERATIONS
;ROUTINE TO ADD ITEM TO INDEX DATA AT TOP OF CORE

INDEX:	MOV #ICBUF,R0
1$:	CLR (R0)+		;FIRST, PUT ITEM IN COMPARISON BUFFER
	CMP R0,#ICBFE
	BLO 1$
				;CLEAR COMPARISON BUFFER
	MOV #ICBUF-1,S1
	CLRB	IDXRF		;CLEAR REPEATED ITEM FLAG
2$:	JSR R5,GCIN		;GET CHARACTER OF INDEX DATA
	CMP	R1,#C.SPC		;SKIP LEADING SPACES OR TABS
	BEQ 2$
	CMP	R1,#C.TAB		; ..
	BEQ 2$
INDX1:	CMP	R1,#C.CR		;COPY THROUGH END OF LINE
	BEQ INDX2		;END.
	INC	S1
	MOVB	R1,@S1		;STORE CHARACTER OF INDEX DATA
	JSR R5,GCIN		;GET NEXT CHARACTER
	CMP	S1,#ICBFE-1	;NEED ONE NULL FOR ASCIZ STRING!
	BLO INDX1		;LOOP IF ROOM
	.PRINT	#INDX		;INDEX ENTRY
	.PRINT	#TOOBIG
	JMP	ILCM5		;ERROR EXIT
INDX2:	MOV #2,R0		;FORM THE ASCIZ OF THE INDEX
	BIT #1,S1		;CHECK FOR BOUNDARY ALIGNMENT
	BEQ .+4
	INC R0
	ADD R0,S1
	SUB #ICBUF,S1		; ..
	MOV XFIRST, R2		;GET ADDRESS OF FIRST ITEM SO FAR
	BEQ INDXV		;IF NONE, LIST IS EMPTY. START IT.
INDXL2:	BIC #IDXCF,F.1		;CLEAR CASE-DIFFERENCE CATCHER
	MOV 4(R2), B		;ADDRESS OF ASCIZ OF OLD ITEM
				;POINTER TO IT.
	MOV #ICBUF, R4		;POINTER TO NEW ITEM
INDXL1:	MOVB @B,R1		;GET CHAR OF OLD
	INC B
	MOVB @R4, C2		;AND ONE OF NEW
	INC	R4
	CMP	R1,C2		;SAME BEFORE CASE MERGE?
	BEQ 3$
	BIS #IDXCF,F.1		;NO. REMEMBER THAT.
3$:	CMP	R1,#141		;CONVERT LC TO UC
	BLT 4$
	BIC #40,R1		; ..
4$:	CMP C2,#141		; ..
	BLT 5$
	BIC #40,C2		; ..
5$:	CMP	R1,C2		;SAME?
	BNE 6$
	TST	R1		;YES. LOOP UNLESS END OF STRINGS
	BNE INDXL1
6$:	CMP	R1,C2		;WHICH IS FIRST?
	BGT INDX3		;NEW ONE IS FIRST, AND DIFFERENT
	CMP	R1,C2		;ARE THEY IDENTICAL?
	BNE IDX4A		;YES. NO NEED FOR NEW COPY. ADJUST POINTERS
	BIT #IDXCF,F.1		;SEEM THE SAME. WERE CASES DIFFERENT?
	BNE INDX3		;YES. ASSUME THESE ARE DIFFERENT
	BISB	#1,IDXRF		;FLAG REPEATED ITEM
IDX4A:	MOV (R2), B		;NO. OLD ONE IS FIRST. LOOK FURTHER
	BEQ INDX5		;END OF LIST. NEW IS LAST
	MOV B, R2			;MOVE LINK TO A
	BR INDXL2		;LOOK FURTHER
;HEADER LAYOUT FOR INDEX ENTRY IS
;
;	.WORD FORWARD LINK
;	.WORD BACKWARD LINK
;	.WORD POINTER TO ASCII TEXT
;	.WORD PAGE NUMBER

INDX3:	TSTB	IDXRF		;AFTER REPEATED ITEM?
	BNE IDX4B		;YES. GO PUT IN REPEAT.
	JSR R5,INDXAD		;ADD ITEM WITH PAGE NO TO STORAGE (UNLINKED?
	MOV 2(R2),B		;WHO PRECEDED OLD?
	BNE ..512		;ANYONE?
	MOV	R4,XFIRST		;NO. NEW IS FIRST OF ALL.
..512:	MOV	R4,2(R2)		;NEW IS PREDECESSOR OF OLD
	MOV	R2,(R4)		;OLD IS SUCCESSOR OF NEW, NO PREDECESSOR
	TST B			;IF ANYONE PRECEDED OLD,
	BEQ ..513
	MOV	R4,@B		;MAKE NEW ONE BE HIS SUCCESSOR
..513:	MOV B,2(R4)		;AND OLD'S PRED IS NOW NEW'S PRED
	BR	.QECM		;RETURN FROM INDEX COMMAND

IDX4B:	MOV 2(R2), R2		;AT END OF REPEAT. GET LAST ONE.
IDX4C:	JSR R5,INDXAP		;ADD POINTERS ONLY (WITH PAGE. NO LINK)
	MOV 4(R2),B		;NEW POINTS TO SAME TEXT AS OLD
	MOV B,4(R4)		; ..
	MOV (R2),B		;GET PREVIOUS SUCCESSOR OF OLD
	MOV	R4,(R2)		;MAKE NEW SUCCEED OLD
	TST B			;IF THERE WAS AN OLD NEXT,
	BEQ ..515
	MOV B,R0		;NEW IS NOW PRED OF OLD NEXT.
	MOV	R4,2(R0)
..515:	MOV B,(R4)		;OLD SUCCESSOR IS SUCCESSOR OF NEW
	MOV	R2,2(R4)		;OLD IS PREDECESSOR OF NEW
	BR	.QECM		;END OF INDEX COMMMAND

INDX5:	TSTB	IDXRF		;AFTER REPEATS?
	BNE IDX4C		;YES. GO ADD AT END.
	JSR R5,INDXAD		;CREATE TEXT AND POINTER BLOCK WITH PAGENO
	MOV	R4,(R2)		;MAKE NEW FOLLOW OLD
	MOV	R2,2(R4)		;AND OLD PRECEDE NEW.
	CLR (R4)
.QECM:	JMP	LCR		;RETURN FROM INDEX COMMAND
INDXV:	JSR R5,INDXAD		;CREATE TEXT AND POINTER BLOCK, PAGE NO
	MOV	R4,XFIRST		;THIS IS FIRST ITEM (AND ONLY)
	CLR (R4)		;NO LINKS AT ALL
	CLR 2(R4)
	BR	.QECM

INDXAP:	MOV XTOP, R4		;GET CURRENT TOP OF INDEX
	ADD #10, R4		;NEED TEN WORDS FOR LINKS
	CMP	R4,FOOTBF		;SPACE BEFORE FOOTNOTES?
	BLO ..517
	JSR R5,EXPAND		;NEED MORE CORE
..517:	MOV XTOP, R4		;NEW VALUE OF XTOP, IF GREW
	MOV	R4,XTOP		;NEW TOP
	ADD #8.,XTOP		;NOW UP FOUR WORDS
INDXAX:	MOV PAGENO,6(R4)	;GET PAGE NUMBER
				;INTO NEW ITEM
	RTS R5			;AND RETURN.

INDXAD:	MOV XTOP, R4		;GET TOP OF INDEX STORAGE
	ADD S1, R4		;NEED 4 WORDS PLUS TEXT
	ADD #8., R4
	CMP	R4,FOOTBF		;LESS THAN BASE OF FOOTNOTES?
	BLO ..518
	JSR R5,EXPAND		;NO. TRY TO EXPAND
..518:	MOV XTOP, R4		;GET TOP OF INDEX
	MOV	R4,-(SP)		;SAVE BASE OF NEW ITEM
	MOV	R4,XTOP		;COMPUTE NEW TOP OF INDEX
	ADD S1,XTOP
	ADD #8.,XTOP
	MOV #ICBUF,FROM		;TRANSFER TEXT INTO BUFFER
	ADD #8., R4		;INTO TEXT AREA
	MOV	R4,TO		;FORM ADDRESS OF TEXT
	MOV	R4,-4(R4)
	MOV XTOP,ENDADR		;FORM LAST ADDRESS OF BLT
..519:	MOV @FROM,@TO		;TRANSFER INDEX ITEM
	ADD #2,FROM
	ADD #2,TO
	CMP TO,ENDADR
	BLO ..519
	MOV (SP)+, R4		;RESTORE BASE OF INDEX.
	CLR (R4)		;NO POINTERS YET.
	CLR 2(R4)
	BR INDXAX		;PUT PAGE NUMBER IN ITEM AND RETURN

FROM:	.WORD 0
TO:	.WORD 0
ENDADR:	.WORD 0
;PRINT INDEX ONTO FILE

PINDX:	JSR R5,OUTNJ		;BREAK COMMAND.  OUTPUT LINE.
	MOV XFIRST, R2		;GET FIRST ITEM IN INDEX
	BEQ PINDXX		;QUIT IF NONE.
	MOV	R2,OIXC		;SAVE CURRENT POINTER
	CLR OIXL		;CLEAR CURRENT LETTER
PINDL1:	MOV OIXC,B		;GET POINTER TO TEXT OF THIS ITEM
	MOV B,R0		; ..
	MOV 4(R0),B
				;ASCIZ POINTER
	MOVB @B,R1		;GET FIRST LETTER
	INC B
	CMP	R1,#141		;LOWER CASE?
	BLT ..520
	BIC #40,R1		;YES.  MAKE UPPER.
..520:	CMP	R1,OIXL		;SAME AS INITIAL LETTER OF PREVIOUS ONE?
	BEQ PINDX1		;YES.  SKIP THIS
	MOV #1, R2		;NO.  OUTPUT AN EXTRA LINE
	MOV	R1,OIXL		;SAVE THIS CHARACTER
	JSR R5,SKIPN
PINDX1:	MOV LMARG, R2		;SPACE IN TO LEFT MARGIN
	JSR R5,NSPAC		; ..
	MOV OIXC, R2		;GET POINTER TO ASCII
	MOV 4(R2), S1		;..
	JSR R5,PSTRAZ		;OUTPUT STRING OF ASCIZ
	MOV RMARG, R2		;NOW GO TO MIDDLE OF LINE
	SUB LMARG, R2		;IF NOT THERE YET
	ASR	R2			; ..
	SUB CPOS, R2		;MINUS CURRENT POSITION
	BLE PIND2		;THERE ALREADY
	MOV #C.SPC,R1		;GET A SPACE
	BIT #1, R2		;MAKE DOTS LINE UP
	BEQ ..522
	JSR R5,FOUT		;OUTPUT A SPACE
..522:	ASR	R2			;OUTPUT ALTERNATE DOTS AND SPACES
..524:	MOV #..523,S1		; ..
	JSR R5,FMSG		; ..
	DEC	R2			;OUTPUT TILL MIDDLE OF LINE
	BGT ..524
PIND2:	MOV #C.SPC,R1		;OUTPUT ONE SPACE
	JSR R5,FOUT		; ..
	MOV OIXC,B		;GET PAGE NUMBER OF THIS ENTRY
	MOV B,R0		; ..
	MOV 6(R0), R3
	JSR R5,DECPRT		;OUTPUT PAGE NUMBER
PINDX2: MOV @B, R4		;GET SUCCESSOR OF THIS ENTRY
	MOV	R4,OIXC		;STORE CURRENT ENTRY FOR NEXT PASS
	BEQ PINDXX		;END OF LIST?  JUMP IF SO.
	MOV B,R0		;TEXT OF CURRENT ITEM
	MOV 4(R0), R2
	MOV 4(R4), D		;TEXT OF NEXT ITEM
	CMP D, R2			;SAME AS CURRENT?
	BNE PINDX3
				;NO.  ON TO NEXT.
	MOV 6(R4), R3		;SAVE.  GET PAGE NUMBERS OF BOTH
	MOV B,R0		; ..
	MOV 6(R0),N1
	CMP N1, R3		;PAGES SAME TOO?
	BNE PINDX4
				;NO.  OUTPUT NEW PAGE NUMBER
	MOV	R4,B			;YES.  DON'T REPEAT PAGE NUMBER
	BR PINDX2		; ..

PINDX3:	MOV NSPNG, R2		;OUTPUT SPACING FOR END OF LINE
	JSR R5,SKIPN		; ..
	BR PINDL1		;GO ON TO NEXT ITEM IN LIST

PINDXX:	MOV NSPNG, R2		;BLANK LINE AT END
	JSR R5,SKIPN		; ..
	MOV XBOT,XTOP
	CLR XFIRST
	JMP ENDBCM		;RETURN FROM PINDX COMMAND

PINDX4:	MOV #',,R1		;PUT COMMA BETWEEN PAGE NUMBERS
	JSR R5,FOUT
	BR	PIND2
.SBTTL FOOTNOTE OPERATIONS

;FOOTNOTE N COMMAND

FOOTN:	JSR R5,RCNO		;HOW MANY LINES TO RESERVE?
	  JMP ILCM		;MUST HAVE SPEC
	CLR	-(SP)
10$:	ADD	NSPNG, (SP)
	DEC	R3
	BNE	10$
	MOV	(SP)+,	R3
	ADD	R3,FOOTC		;ADD TO RESERVED FOOTNOTE LINES
..145:	JSR R5,CCIN		;SKIP REST OF COMMAND LINE
	CMP	R1,#C.LF		; ..
	BNE ..145
	BR FOOTN3		;YES. END OF LINE.

FOOTN2:	JSR R5,CCIN		;READ A CHARACTER
FOOTN1:	JSR R5,WCIFTN		;WRITE CHARACTER IN BUFFER
	CMP	R1,#C.LF		;END OF LINE?
	BNE FOOTN2
FOOTN3:	JSR R5,CCIN		;YES. SEE WHAT CHAR AFTER LF IS
	CMP	R1,#C.EOF		;END OF FILE?
	BNE ..148
	MOV #C.EFNT,R1		;YES. FAKE END OF FOOTNOTE CHAR.
..148:	CMP	R1,#C.EFNT		;END FLAG (EXCL)?
	BNE FOOTN1		;NO. STORE ANOTHER LINE
	JSR R5,WCIFTN		;YES. STORE THIS CHARACTER
	JMP	LCR		;AND RETURN TO COMMAND ROUTINE

;START PROCESSING THE FOOTNOTE BUFFER. CALLED FROM BPAGE
;WHEN FOOTP3 POINTER IS NOT EMPTY

FOOTGO:	MOV #100., R2		;SET HUGE PAGE SIZE TO PREVENT EXTRA FORMS
	MOV NLPG,R0		;AND GET CURRENT LENGTH
	MOV	R2,NLPG
	MOV R0, R2
	SUB LINEC, R2		;DISTANCE TO END
	BLOS ..150		;IF SOME LEFT TO GO,
	JSR R5,SKIPN		; SKIP TO END OF PAGE BEFORE FOOTNOTES
..150:	MOV RMARG,-(SP)		;SAVE THESE ITEMS OVER FOOTNOTE PROCESSING
	MOV LMARG,-(SP)
	MOV PARIND,-(SP)	;SAVE PARA INDENTING
	MOV NSPNG,-(SP)
	MOV GCSCH,-(SP)
	MOV INDCT,-(SP)		;OCCASSIONALLY WE NEED TO SAVE THIS
	CLR INDCT		;CLEAR IT FOR RANDOM FAILURES
	BIS #FOOTFG,F.1		;FLAG IN FOOTNOTE PROCESSING
	MOV #-1,GCSCH		;CLOBBER ANY SAVED CHARACTERS
	MOV #FOOTWB, R4		;PREPARE END-OF-LINE-HOLDING-BUFFER
	JSR R5,CSP		; ..
	MOV	R2,FOOTS1		; ..
	MOV B,FOOTS2		; BUFFER IS EMPTY
	BIC #GCINF,F.1		;NO SAVED INFO. WAS THERE ANY?
	BEQ FOOTS3		;NO. LEAVE.
FOOTSB:	JSR R5,GGCINP		;GET A CHARACTER FROM SAVED BUFFER
	  BR FOOTS3		;NO MORE
	MOV #FOOTS1, R4		;SAVE BUFFER
	JSR R5,WCI
	CMP	FOOTS2,#FTBUFE
	BLO	FOOTSB		;LOOP UNTIL SAVED BUFFER ALL MOVED
	.PRINT	#INLINE		;SAVED INPUT LINE TOO LONG
	.PRINT	#TOOBIG
	JSR	R5,ONPAG
	BR	FOOTN5		;FORGET IT

FOOTS3:	JSR R5,LINSET		;INITIALIZE LINE FOR START OF FOOTNOTE
	JMP LGO			;AND GO PROCESS SAVED FOOTNOTE COMMANDS

;HERE WHEN LINE ROUTINE DISCOVERS INITIAL EXCLAMATION

FOOTND:	JSR R5,OUTNJ		;YES. FINISH UP LINE
	MOV FOOTP3, R2		;ANY MORE FOOTNOTES COMING?
	CMP	R2,FOOTP4		; ..
	BEQ ..152
	JMP LGO			;YES. GO READ SOME MORE
..152:	CMP	R2,FOOTP2		;ANY UNPROCESSED FOOTNOTES TO ADD?
	BHIS FOOTN6		;NO.
	MOV	R2,T5		;YES.  ADD THEM TO LIST.
	MOV FOOTP2,B		;SAVE POINTER TO REMAINING COMMANDS
	MOV B,T6		; ..
	MOV FOOTP1, R2
	MOV	R2,FOOTP2
	MOV	R2,FOOTP3
	MOV	R2,FOOTP4
FOOTN4:	MOV #T5, R4		;COPY T5 STRING TO FOOTP1
	JSR R5,GCI		;GET A CHARACTER
	  BR FOOTN5		;NO MORE.
	JSR R5,WCIFTN		;WRITE IN FOOTNOTE POINTER 1
	BR FOOTN4		;LOOP TILL DONE
FOOTN6:	MOV FOOTP1, R2		;CLEAR FOOTNOTE BUFFERS
	MOV	R2,FOOTP2		; ..
	MOV	R2,FOOTP3		; ..
	MOV	R2,FOOTP4		; ..
FOOTN5:	BIC #EXSP3+FOOTFG,F.1	;INITIALIZE LEFT/RIGHT FLAG
				; AND MARK NOT IN FOOTNOTE MODE NOW
	MOV (SP)+,INDCT		;RESTORE SAVED PARAMTERS
	MOV (SP)+,GCSCH
	MOV (SP)+,NSPNG
	MOV (SP)+,PARIND
	MOV (SP)+,LMARG
	MOV (SP)+,RMARG
	MOV PNLPG,NLPG		;RESET LENGTH OF PAGE
				; ..
	MOV FOOTS1, R2		;WAS PARTIAL LINE SAVED?
	CMP	R2,FOOTS2		; ..
	BEQ FOOTS4		;NO.
	MOV FOOTS2,B		;YES. PUT POINTER IN GCINP
	MOV	R2,GCINP		; ..
	MOV B,GCINP+2		; ..
	BIS #GCINF,F.1		;AND FLAG TO LOOK AT THAT BUFFER
FOOTS4:	JMP FOOTX		;RETURN TO LINE PROCESSOR

WCIFTN:	MOV FOOTP2, R2		;WRITE IN FOOTNOTE BUFFER, CHECKING SIZE
	MOV JOBREL,B		; ..
	CMP	R2,B			; ..
	BLO WCIFT1		;OK. NO PROBLEM.
	JMP EXPERR		;CAN'T HAVE IT. GIVE UP.
WCIFT1:	MOV #FOOTP1, R4		;NOW WRITE CHARACTER
	BR WCI			; ..
.SBTTL HANDY-DANDY SUBROUTINES

;ROUTINE TO COMPUTE EMPTY STRING POINTER

CSP:	MOV	R4, R2
	DEC	R2
	MOV	R2,B
	RTS R5

;ROUTINES TO GET CHARACTER AND INCREMENT STRING POINTER

GGCINP:	MOV #GCINP, R4
	BR GCI
GLOUT:	MOV #LOUT1, R4		;PARTICULAR ARGUMENT
GCI:	MOV (R4), R2		;GET FIRST POINTER
	CMP	R2,2(R4)		;ANYTHING IN STRING
	BHIS	CPOPJ		;NO.  NON-SKIP RETURN.
	INC (R4)		;YES.  COUNT AND GET FIRST POINTER
	MOV (R4), R2
	MOVB (R2), R1
	TST	(R5)+		;FORCE SKIP RETURN
CPOPJ:	RTS R5

;ROUTINES TO WRITE CHARACTER AND INCREMENT POINTERS

WCI:	INC 2(R4)
	MOVB	R1,@2(R4)	;STORE IT
	RTS R5

WLNIN1:	MOV	#LNIN1,R4
	JSR	R5,WCI		;WRITE CHAR IN LINE BUFFER
	CMP	2(R4),#LINBFE
	BLO	1$		;OK, BUFFER NOT FULL
	.PRINT	#INLINE
	.PRINT	#TOOBIG
	JSR	R5,ONPAG
1$:	RTS	R5		;PRESS ONWARD

;I/O SUBRS

FMSGL:	INC S1
FMSG:	MOVB @S1, R1
	BEQ	CPOPJ		;RETURN ON NULL
	JSR R5,FOUT		;OUTPUT CHARACTER
	BR FMSGL		;LOOP

FOUT:	CMP	PAGENO,LOWPAG	;IN BOUNDS?
	BLO	11$		; TOO LOW, IGNORE IT
	CMP	PAGENO,HGHPAG
	BHI	12$		;  TOO HIGH, QUIT
	TST	OBFCTR		;SEE IF SPACE IN OUTPUT BUFR
	BNE	10$		;IF YES, JUST PLUNK IN THE CHAR
	JSR	R5,	OUTPUT	;IF NOT, WRITE THE BUFFER
10$:	DEC	OBFCTR
	MOVB	R1,	@OBFPTR
	INC	OBFPTR		;BUMP THE BUF PTR
11$:	RTS R5			;AND RETURN
12$:	MOV	#-1,HGHPAG	;SET HIGH PAGE BACK TO INFINITY
	JMP	ENDFI2

FIN:	DEC IBFCTR		;ANYTHING IN BUFFER?
	BGT FINOK		;YES.
				;NO. GET BUFFER FULL.

INPUT:	.READW	#EMTBLK, ICHAN, #IN.BUF, #IBFSIZ/2, INBLK

	BCC	10$
	CMPB	#1,	@#52
	BLO	5$		;CHAN NOT OPEN, TRY NEXT FILE
	BEQ	7$
5$:	CLR	INBLK		;EOF SEEN (OR NOT OPEN)
	INC	ICHAN		;TRY NEXT CHAN IN LINE
	CMPB	#10,	ICHAN	;INPUT CHANNELS GO FROM 3-10
	BHIS	INPUT		;STILL A CHANCE
	BR	FINEOF		;DONE 'EM ALL
7$:	JMP	RDERR3

10$:	INC	INBLK
	MOV	#IBFSIZ, IBFCTR
	MOV	#IN.BUF-1, IBFPTR
FINOK:	INC	IBFPTR		;POINT TO CHARACTER
	MOVB	@IBFPTR, R1	;NO.  GET CHAR.
	BEQ	FIN		;IGNORE NULLS
	TST	PEEK.F		; PEEKING?
	BEQ	2$		; NO
	CLR	PEEK.F		; CLEAR IT RIGHT OFF
	CMPB	R1,#15		; A <CR>?
	BEQ	1$		; YES
	CMPB	R1,#C.SEMI	; OR A SEMI-COLON
	BNE	2$		; NO
1$:	DEC	IBFPTR		; RESET PTR
	INC	IBFCTR		; AND THIS ONE
2$:	CMP	R1,#177		;AND RUBOUTS
	BEQ FIN			;GET ANOTHER
	RTS R5			;RETURN CHARACTER

FINEF1:	MOV EOFPTR,R1		;INITIAL EOF POINTER
	MOV	R1,INEOFP
	DEC INEOFP
FINEOF:	INC INEOFP		;GET LITERAL CHARACTER
	MOVB @INEOFP, R1
	BEQ FINEF1		;IF NONE, RESTART LITERAL
	RTS R5			;NO.  RETURN CHARACTER

EOFPTR:	.WORD EOFDAT-1
EOFDAT:	.BYTE C.CR,C.LF,C.EOF,0
	.EVEN
;THIS ROUTINE OUTPUTS THE CURRENT LINE BUFFER

OUTPUT:	TST	OBFCTR
	BEQ	10$
5$:	CLRB	@OBFPTR		;CLEAR PARTIAL BUFFER TO NULLS
	INC	OBFPTR
	DEC	OBFCTR
	BNE	5$

.IF	EQ,DBLBUF
10$:	.WRITW	#EMTBLK, OCHAN, #OU.BF1, #OBFSIZ/2, OUTBLK
	BCS	20$
15$:	INC	OUTBLK
	MOV	#OBFSIZ, OBFCTR
	MOV	#OU.BF1, OBFPTR
	RTS	R5
.IFF
10$:	.WAIT	OCHAN
	BCS	17$
12$:	MOV	R1,	-(SP)
	MOV	OBFSWT,	R1
	.WRITE	#EMTBLK, OCHAN, OB(R1), #OBFSIZ/2, OUTBLK
	BCS	20$
15$:	ADD	#2,	R1
	BIC	#^C<2>,	R1
	MOV	OB(R1),	OBFPTR
	MOV	R1,	OBFSWT
	MOV	(SP)+,	R1
	MOV	#OBFSIZ,	OBFCTR
	INC	OUTBLK
	RTS	R5
17$:	TSTB	@#52
	BEQ	12$			;IF CHAN NOT OPEN, IGNORE
	BR	WRERR3			;HARDWARE ERROR!
.ENDC

20$:	CMPB	#1,	@#52
	BLO	15$
	BEQ	WRERR3
	.PRINT	#..209
	BR	RUNOFF
;READ WORD OF SIXBIT INTO A FROM TYI

SIXBRL:	JSR R5,TYI		;GET A CHARACTER
	CMP	R1,#'Z		;LETTER?
	BGT ..171
	CMP	R1,#'A		; ..
	BGE SIXBR1		;YES
..171:	CMP	R1,#'9		;DIGIT?
	BGT ..168
	CMP	R1,#'0		; ..
	BLT	..168
SIXBR1:	SUB #40,R1		;MAKE SIXBIT
	TST B			;ROOM IN ANSWER?
	BEQ SIXBRL
	MOVB	R1, R2		;FIX UP LATER
	BR SIXBRL		;LOOP

;READ CHARACTER FROM TTY.  CONVERT ALTMODES, LC, DISCARD CR AND NULL

TYI:	.TTYIN
	MOV	R0,	R1
	CMP	R1,#172		;LOWER CASE?
	BGT ..164
	CMP	R1,#141		; ..
	BLT ..164		;NO
	BIC #40,R1		;YES, MAKE UPPER
..164:	CMP	R1,#15		;CARRIAGE RETURN?
	BEQ TYI
	TST	R1		;OR NULL?
	BEQ TYI			;YES.  DISCARD.
	CMP	R1,#176		;ALTMODE?
	BEQ ..167
	CMP	R1,#175		; ..
	BNE ..168
..167:	MOV #33,R1		;YES.  MAKE ESCAPE.
..168:	RTS R5			;RETURN CHARACTER


YESNO:	.TTYIN
	CMP R0, #'Y		;IS FIRST CHAR A Y?
	BEQ ..175
	ADD #6,R5		;NO.  SKIP.
..175:	JSR	PC,	TTSKIP
	RTS R5			;YES.  DON'T SKIP.

WRERR3:	.PRINT	#..176
	BR	RUNOFF		;RESTART

RDERR3:	.PRINT	#..177
	BR	RUNOFF		;RESTART
EXPERR:
EXPAND:	.PRINT	#..193
	JMP ENDFIL

DECTYO:	MOV	R3,	-(SP)
	CLR	R3
1$:	INC	R3
	SUB	#10., (SP)
	BGE	1$
	ADD	#60+10., (SP)
	DEC	R3
	BEQ	2$
	JSR	R5,	DECTYO
2$:	.TTYOUT	(SP)+
	RTS	R5

TTSKIP:	.TTYIN
	CMP	R0,	#12		;SKIP TO LINEFEED
	BNE	TTSKIP
	RTS	PC
.SBTTL INITIALIZATION

RESTRT:	BR	RUNOFF	;MONITOR RESTARTS HERE
	.GLOBL	START
START:	.PRINT	#VERMES		;SIGN ON
	BIS	#20000,@#44	;SET RE-ENTER BIT IN JSW
RUNOFF:	.RCTRLO		;TURN ON TERMINAL PRINTING
	MOVB	#3,	ICHAN	;INITIAL INPUT CHANNEL
	CLRB	OCHAN		;INITIAL OUTPUT CHANNEL
	MOV #-1,GCSCH		;NO SAVED CHARACTER
	MOV #-1,ULMCH		; ..
	MOV #INLPG, R2		;INITIAL LENGTH OF PAGE
	MOV	R2,PNLPG
	MOV	R2,NLPG
	MOV #IRMRG, R2		;INITIAL RIGHT MARGIN
	MOV	R2,PRMRG
	MOV	R2,RMARG
	MOV #ILMRG,LMARG	;INITIAL LEFT MARGIN
	MOV #40,CAS		;INITIAL CASE SETTING IS LOWER
	MOV #1,PAGENO		;INITIAL PAGE NUMBER
	MOV #1,NSPNG		;INITIAL SPACING
	MOV #5,PARIND		;INITIAL PARAGRAPH INDENTING
	CLR TTLP1		;NO TITLE TO START WITH
	CLR TTLP2
	CLR STTLP1		;CLEAR SUBTITLE TOO
	CLR STTLP2		; ..
	CLR	YEAR		;NO DATE SET YET
	CLR LINEC		;START AT TOP OF PAGE
	CLR INDCT		;AND LEFT OF PAPER
	CLR NTABS		;NO TABS YET
	CLR FOOTC		;NO FOOTNOTE LINES HELD YET
	CLR XFIRST		;NOTHING IN THE INDEX


;***D.S. 27-AUG-79
	MOV #CNDLVL,R0
1$:	CLR (R0)+
	CMP R0,#CNDVAR+26.
	BLO 1$
;***

.IIF	NE,HYP	CLR HYPH	;NO HYPHENATION ASSUMED
	MOV #LINBF, R4		;INITIALIZE LINE INPUT POINTER
	JSR R5,CSP
	MOV	R2,LNIN1		;STORE.
	MOV R2,	LNIN2		; ..
	CLR IBFCTR		;SET CHARACTER COUNTS
.IIF	NE,DBLBUF	CLR	OBFSWT	;SET TO FIRST OUTPUT BUFFER
	MOV #OBFSIZ,	OBFCTR	;SET CHARACTER COUNTS
	MOV #IN.BUF-1,	IBFPTR	;INITIALIZE POINTERS
	MOV #OU.BF1,	OBFPTR	;INITIALIZE POINTERS
SETUP0:	MOV	#JUSTF+PJUSTF+FILLF+FFDSW+NUMBF,F.1	;INITIAL FLAGS
	CLR	LOWPAG		;SET PAGE LIMITS TO 0
	MOV	#-1,HGHPAG	; AND INFINITY
	MOV	#66.,HWPLN	;DEFAULT VALUE FOR HARDWARE PAGE LENGTH
	MOVB	#C.LPUS,ULCHAR	;SET DEFAULT UNDERLINE CHAR.
	CLRB	ULNEXT		; AND CLEAR U:S FLAG
	MOV	@#42, SP	;RESTORE STACK
	.SRESET			;UNLOAD ODD HANDLERS, ETC
.IIF	NE,DBLBUF	.QSET	#IOQUE, #2	;ADD 2 ELEMENTS TO IO QUEUE ;?gk""*&!!'!,R1		;ILLEGAL CSI, TELL USER WHY
	BEQ	ICERR1		;ILLEGAL COMMAND
	CMPB	R1,#1
	BEQ	RDERR2		;ILLEGAL DEVICE
	CMPB	R1,#3
	BEQ	WRERR2		;DEVICE FULL
	CMPB	R1,#4
	BNE	ICERR1		;ILLEGAL ERROR
	BR	WRERR1		;NO INPUT FILE
CC:	MOV	R0,JOBFF	;SAVE START OF FREE AREA
	CLR	INBLK		;INITIALIZE INPUT/OUTPUT BLOCK NBRS
	CLR	OUTBLK
	MOV	(SP)+,R1	;GET SWITCH COUNT GIVEN BY CSI
EE:	BEQ	RNGO		;NO SWITCHES GIVEN
	MOV	(SP)+,R3	;GET SWITCH
.IF	NE,HYP
	CMPB	R3,	#'H	;HYPHENATE?
	BEQ	10$		;SET HYPHENATE
	.ENDC
	CMPB	R3,	#'F
	BEQ	30$		;SIMULATE FORMFEED
	CMPB	R3,	#'P
	BEQ	40$		;PAUSE BETWEEN PAGES
	CMPB	R3,	#'U
	BEQ	50$		;FIGURE OUT UNDERSCORE
	CMPB	R3,	#'L
	BEQ	60$		;PAGE LIMIT OPTION
	CMPB	R3,	#'?
	BEQ	70$		;IF HELP NEEDED
	BR	ICERR1		;BAD SWITCH = ILLEGAL COMMAND
2$:	TST	R3		;SEE IF SWITCH HAD A VALUE
	BGE	5$		;IF NOT
	TST	(SP)+		;IF SO, IGNORE IT
5$:	DEC	R1		;COUNT SWITCHES
	BR	EE		;CONTINUE

.IF	NE,HYP
10$:	MOV	SP,	HYPH		;SET HYPHENATE
	BR	2$
	.ENDC
30$:	BIC	#FFDSW, F.1		;SIMULATE FF
	TST	R3		;SEE IF VALUE FOR FORM LENGTH
	BPL	5$		; NO,USE DEFAULT OF 66.
	MOV	(SP)+,R3	;GET VALUE
	CMP	R3,#15.		;SHOULD HAVE AT LEAST 15. LINES/PAGE
	BLO	ICERR1		; TOO SHORT, TOO BAD
	MOV	R3,HWPLN	;  SET HARDWARE PAGE LENGTH VALUE
	BR	5$		;GO LOOK FOR ANOTHER SWITCH
40$:	BIS	#PAUSF, F.1		;PAUSE BETWEEN PAGES
	BR	2$
50$:	TST	R3			;SEE IF UNDERSCORE HAD OPTION
	BGE	5$			;IF NO
	MOV	(SP)+,	R3		;IF YES, GET IT
	CMP	R3,	(PC)+
	.RAD50	/B/
	BNE	52$
	BIS	#ULBSF+ULMODE, F.1
	BR	5$
52$:	CMP	R3,	(PC)+
	.RAD50	/C/
	BNE	54$
	BIS	#ULMODE, F.1
	BR	5$
54$:	CMP	R3,	(PC)+
	.RAD50	/N/
	BNE	55$
	BIS	#ULSUPF, F.1
	BR	5$
55$:	CMP	R3,(PC)+
	.RAD50	/S/
	BNE	ICERR1		;ILLEGAL OPTION
	MOVB	#C.MINS,ULCHAR	; UNDERLINE WITH -
	INCB	ULNEXT		;  ON NEXT LINE
	BR	5$
60$:	TST	R3		;SEE IF LIMIT OPTION HAS VALUE
	BPL	ICERR1		; NO, ILLEGAL COMMAND
	TST	HGHPAG		;-1 INITIALLY
	BPL	61$		; IT'S BEEN SET
	MOV	(SP),HGHPAG	;OK, HERE IS HIGH VALUE
61$:	MOV	(SP)+,LOWPAG	; LOW OR ONLY VALUE
	BR	5$
70$:	.PRINT	#HELPTX
JMPSET:	JMP	SETUP0		;RESTART AFTER CALL FOR HELP
;ERRORS DURING SPECIFICATIONS

ICERR1:	.PRINT	#..207
	BR	JMPSET

RDERR2:	.PRINT	#..208
	BR	JMPSET

WRERR1:	.PRINT	#..210
	BR	JMPSET
WRERR2:	.PRINT	#..209
	BR	JMPSET

;HERE WHEN OPTIONS ALL SPECIFIED

RNGO:	.SETTOP	#-2		;ASK FOR ALL CORE
	MOV	R0,JOBREL	; TAKE WHAT WE CAN GET
	MOV JOBFF, R4		;GET FREE AREA
	MOV	R4,XTOP		;INITIAL INDEX POINTERS
	MOV	R4,XBOT		; ..
	MOV JOBFF, R2
	MOV JOBREL, R4		;GIVE HALF OF CORE TO FOOTNOTES
	ADD	R2,R4		; MIDDLE = TOP + BOTTOM
	ROR	R4		;  /2
	MOV	R4,FOOTBF		;SAVE FOR COMPARISON LATER
	JSR R5,CSP		; ..
	MOV	R2,FOOTP1		;STORE
	MOV B,FOOTP2
	MOV	R2,FOOTP3		;IN BOTH POINTERS
	MOV B,FOOTP4
	BIT #FFDSW,F.1		;FORMFEED OR LF'S?
	BEQ RNG1			;LINEFEEDS, REQUEST POSITIONING
	MOV #C.FF,R1		;OUTPUT FORMFEED
	JSR R5,FOUT
RNG2:	JSR R5,LINSET		;SET UP FOR LINE
	MOV #5, R2		;NO TITLE YET, SO SKIP HEADING AREA
	JSR R5,SKIPN		; ..
	JMP LGO			;AND INTO MAIN LOOP, LINE INPUT

RNG1:	.PRINT	#RNGM1		;ASK FOR POSITIONING
	JSR	PC,	TTSKIP	;SKIP TO LINEFEED
	BR RNG2			;AND GO.

ENDFIL:	JSR R5,OUTNJ		;FINISH LAST LINE
	JSR R5,FORM		;TO TOP OF FORM
ENDFI2:	CMP OBFCTR, #OBFSIZ	;CHECK FOR PARTIAL LINE
	BEQ 11$
.CLOSE	ICHAN
	JMP RUNOFF		;IN CASE OF CONTINUE
	.CSECT	STRING		;PUT IN WITH COMMAND STRINGS
	.NLIST	BEX
VERMES:	.ASCIZ /RT-11 RUNOFF C00A-10/
..193:	.ASCIZ <15><12>/?NOT ENOUGH CORE/
..523:	.ASCIZ / ./
CRLFM:	.BYTE 15,12,0
ILCMM:	.ASCIZ /?ILLEGAL COMMAND: /
TTL:	.ASCII	/?TITLE/<200>
STTL:	.ASCII	/?SUBTITLE/<200>
INDX:	.ASCII	/?INDEX ENTRY/<200>
INLINE:	.ASCII	/?INPUT LINE/<200>
TOOBIG:	.ASCII	/ TOO LONG /<200>
ILCMM2:	.ASCII /ON OUTPUT PAGE  /<200>
JUSRM1:	.ASCIZ /?CAN'T JUSTIFY LINE:  /
PGTXT:	.BYTE	120,141,147,145,40,0	;^PAGE
..176:	.ASCIZ <15><12>/?ERROR ON OUTPUT FILE./
..177:	.ASCIZ <15><12>/?ERROR ON INPUT DEVICE/
..207:	.ASCIZ /?ILLEGAL COMMAND/
..208:	.ASCIZ /?ILLEGAL DEVICE/
..209:	.ASCIZ /?DEVICE FULL/
..210:	.ASCIZ	/?FILE NOT FOUND/
HALTM:	.ASCIZ <15><12>/FATAL ERROR IN RUNOFF, ABORTING/
RNGM1:	.ASCII /POSITION PAPER, TYPE RETURN./<200>

HELPTX:	.ASCII	<15><12>!GENERAL COMMAND FORMAT IS:!<15><12>
	.ASCII	!DEV:OUTFIL=DEV:INFIL1,DEV:INFIL2.../S1/S2...!<15><12>
	.ASCII	!INPUT DEFAULT EXTENSION IS .RNO!<15><12>
	.ASCII	!OUTPUT DEFAULT EXTENSION IS .DOC!<15><12>
	.ASCII	!LEGAL SWITCHES ARE:!<15><12>
	.ASCII	%/F!N	- SIMULATE FORMFEEDS WITH LINEFEEDS%<15><12>
	.ASCII	!	  TO MAKE PAGE 'N' LINES LONG (DEFAULT 66)!<15><12>
.IF	NE,HYP
	.ASCII	!/H	- HYPHENATE WORDS AS NECESSARY TO JUSTIFY LINES!<15><12>
	.ASCII	!	 (N.B. HYPHENATION MAY NOT BE CORRECT)!<15><12>
	.ENDC
	.ASCII	%/L!N	- LIMIT - PRINT PAGE N ONLY%<15><12>
	.ASCII	%/L!M!N	- LIMITS - PRINT FROM PAGE M TO N%<15><12>
	.ASCII	!/P	- PAUSE BETWEEN PAGES (TYPE ANY CHAR TO CONTINUE)!<15><12>
	.ASCII	!/U	- UNDERSCORE BY OVERPRINTING LINE (DEFAULT)!<15><12>
	.ASCII	!/U:B	- BACKSPACING UNDERSCORE!<15><12>
	.ASCII	!/U:C	- NON-SPACING UNDERSCORE!<15><12>
	.ASCII	!/U:S	- NEXT LINE UNDERSCORE WITH -!<15><12>
	.ASCII	!/U:N	- SUPPRESS UNDERSCORES!<15><12>
	.ASCIZ	!/?	- PRINT THIS TEXT!<15><12>

MONTBL:	.ASCIZ	/J/<'A!40><'N!40>
	.ASCIZ	/F/<'E!40><'B!40>
	.ASCIZ	/M/<'A!40><'R!40>
	.ASCIZ	/A/<'P!40><'R!40>
	.ASCIZ	/M/<'A!40><'Y!40>
	.ASCIZ	/J/<'U!40><'N!40>
	.ASCIZ	/J/<'U!40><'L!40>
	.ASCIZ	/A/<'U!40><'G!40>
	.ASCIZ	/S/<'E!40><'P!40>
	.ASCIZ	/O/<'C!40><'T!40>
	.ASCIZ	/N/<'O!40><'V!40>
	.ASCIZ	/D/<'E!40><'C!40>

	.EVEN
	.LIST BEX

	.CSECT
RUNEND:	.END	START
 